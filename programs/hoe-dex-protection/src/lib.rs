use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer};
use std::collections::HashSet;

// Program ID (replace with actual ID after deployment)
// FIX: Replace this with the actual program ID generated by `anchor build`
declare_id!("hoedexprotect1111111111111111111111111111111111111");

// Constants for fee and protection limits
const MAX_EARLY_TRADE_FEE_BPS: u64 = 1000; // 10% maximum early trade fee
const MAX_TIER_FEE_BPS: u64 = 1000; // 10% maximum tier-based fee
const MAX_TRADE_SIZE_BPS: u64 = 1000; // 10% of pool size
const MAX_PRICE_IMPACT_BPS: u64 = 1000; // 10% maximum price impact
const MAX_COOLDOWN_SECONDS: u64 = 3600; // 1 hour maximum cooldown
const MIN_CIRCUIT_BREAKER_COOLDOWN: u64 = 60; // 1 minute minimum cooldown
const MAX_BLACKLIST_SIZE: usize = 100; // Maximum number of blacklisted traders
const MAX_FEE_TIERS: usize = 10; // Maximum number of fee tiers
const MINIMUM_FEE: u64 = 1; // Minimum fee in token units
const MAX_TOKEN_DECIMALS: u8 = 9; // Maximum token decimals supported
const MIN_FEE_TIER_SPACING_BPS: u64 = 100; // 1% of max_daily_volume minimum spacing
const EMERGENCY_TIMELOCK_SECONDS: u64 = 3600; // 1 hour emergency action delay
const ADMIN_UPDATE_COOLDOWN: u64 = 86400; // 24 hours between admin updates
const BATCH_BLACKLIST_MAX_SIZE: usize = 50; // Maximum traders per batch blacklist

// Fee mode constants for tracking fee application
const FEE_MODE_NONE: u8 = 0; // No fee applied
const FEE_MODE_EARLY_TRADE: u8 = 1; // Early trade fee applied
const FEE_MODE_TIER_BASED: u8 = 2; // Volume-based tier fee applied

// --- Constants ---
pub const SECONDS_PER_HOUR: u64 = 3600;
pub const SECONDS_PER_DAY: u64 = 86400;
pub const SECONDS_PER_WEEK: u64 = 604800;
pub const MINIMUM_FEE_BPS: u64 = 1; // 0.01%
pub const MAXIMUM_FEE_BPS: u64 = 1000; // 10%
pub const MINIMUM_FEE: u64 = 1; // Minimum fee in lamports
pub const POOL_ID_SEED: &[u8] = b"pool_id";

#[program]
pub mod hoe_dex_protection {
    use super::*;

    /// Initialize a new pool with protection parameters
    /// 
    /// This function sets up the initial state of the pool with all necessary
    /// protection mechanisms and parameters. It performs extensive validation
    /// to ensure the pool starts in a safe state.
    pub fn initialize_pool(
        ctx: Context<contexts::InitializePool>,
        early_trade_fee_bps: u64,
        early_trade_window_seconds: u64,
        max_trade_size_bps: u64,
        min_trade_size: u64,
        cooldown_seconds: u64,
        max_daily_volume: u64,
        max_price_impact_bps: u64,
        circuit_breaker_threshold: u64,
        circuit_breaker_window: u64,
        circuit_breaker_cooldown: u64,
        rate_limit_window: u64,
        rate_limit_max: u32,
        fee_tiers: Vec<FeeTier>,
        snipe_protection_seconds: u64,
    ) -> Result<()> {
        let pool_state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp;

        // Validate fee tiers
        utils::validate_fee_tiers(&fee_tiers)?;

        // Initialize pool state
        pool_state.version = 1;
        pool_state.migration_flag = false;
        pool_state.is_initialized = true;
        pool_state.admin = ctx.accounts.admin.key();
        pool_state.emergency_admin = ctx.accounts.admin.key(); // Initially same as admin
        pool_state.token_mint = ctx.accounts.token_mint.key();
        pool_state.token_decimals = ctx.accounts.token_mint.decimals;
        pool_state.total_fees_collected = 0;
        pool_state.total_liquidity = 0;
        pool_state.is_paused = false;
        pool_state.is_emergency_paused = false;
        pool_state.is_finalized = false;
        pool_state.pool_start_time = current_time as u64;
        pool_state.last_update = current_time as u64;
        pool_state.last_admin_update = current_time as u64;
        pool_state.emergency_action_scheduled_time = 0;
        pool_state.pending_update = None;
        pool_state.trade_settings = TradeSettings {
            max_size_bps: max_trade_size_bps,
            min_size: min_trade_size,
            cooldown_seconds,
            last_trade_time: 0,
            early_trade_fee_bps,
            early_trade_window_seconds,
        };
        pool_state.rate_limit = RateLimitSettings {
            window: rate_limit_window,
            count: 0,
            max: rate_limit_max,
            last_reset: current_time as u64,
        };
        pool_state.circuit_breaker = CircuitBreakerSettings {
            threshold: circuit_breaker_threshold,
            window: circuit_breaker_window,
            cooldown: circuit_breaker_cooldown,
            last_trigger: 0,
        };
        pool_state.volume = VolumeSettings {
            volume_24h: 0,
            last_update: current_time as u64,
            last_decay: current_time as u64,
            max_daily: max_daily_volume,
        };
        pool_state.protection = ProtectionSettings {
            snipe_protection_seconds,
            max_price_impact_bps,
        };
        pool_state.fee_tiers = fee_tiers;
        pool_state.fee_tiers_locked = false;
        pool_state.default_fee_bps = None;
        pool_state.trader_blacklist = Vec::new();

        emit!(PoolInitialized {
            pool: pool_state.key(),
            admin_pubkey: pool_state.admin,
            ts: current_time,
        });

        Ok(())
    }

    /// Add liquidity to the pool
    ///
    /// This function allows the admin to add liquidity to the pool before it starts.
    /// - Validates: token program, amount, pool state, token accounts
    /// - Transfers: tokens from admin to pool
    /// - Updates: pool state with new liquidity and timestamps
    pub fn add_liquidity(ctx: Context<contexts::AddLiquidity>, amount: u64) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate token accounts
        state.check_token_mint(&ctx.accounts.token_mint)?;
        state.check_token_account(&ctx.accounts.admin_token_account, &state.token_mint)?;
        state.check_token_account(&ctx.accounts.pool_token_account, &state.token_mint)?;

        // Validate amount
        validate_condition!(amount > 0, ErrorCode::InvalidAmount);

        // Transfer tokens from admin to pool
        let cpi_ctx = with_pool_signer(
            &crate::ID,
            state,
            &[ctx.accounts.admin_token_account.to_account_info(), ctx.accounts.pool_token_account.to_account_info()],
        )?;

        token::transfer(
            cpi_ctx,
            amount,
        )?;

        // Update pool state
        state.total_liquidity = state.total_liquidity.checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;
        state.last_update = current_time;

        // Emit event
        state.emit_liquidity_added(&ctx.accounts.admin.key(), amount, current_time as i64);

        Ok(())
    }

    /// Remove liquidity from the pool
    ///
    /// This function allows the admin to withdraw liquidity from the pool.
    /// - Validates: token program, admin, pool state, token accounts, amount
    /// - Transfers: tokens from pool to admin
    /// - Updates: pool state with reduced liquidity and timestamps
    pub fn remove_liquidity(ctx: Context<contexts::AdminAction>, amount: u64) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate amount
        validate_condition!(amount > 0, ErrorCode::InvalidAmount);
        validate_condition!(
            amount <= state.total_liquidity,
            ErrorCode::InsufficientLiquidity
        );

        // Transfer tokens from pool to admin
        let cpi_ctx = with_pool_signer(
            &crate::ID,
            state,
            &[ctx.accounts.pool_token_account.to_account_info(), ctx.accounts.admin_token_account.to_account_info()],
        )?;

        token::transfer(
            cpi_ctx,
            amount,
        )?;

        // Update pool state
        state.total_liquidity = state.total_liquidity.checked_sub(amount)
            .ok_or(ErrorCode::Overflow)?;
        state.last_update = current_time;

        // Emit event
        state.emit_liquidity_removed(&ctx.accounts.admin.key(), amount, current_time as i64);

        Ok(())
    }

    /// Execute a trade in the pool with all protection mechanisms active
    ///
    /// This function implements the core trading logic with multiple layers of protection:
    /// - Snipe protection
    /// - Rate limiting
    /// - Circuit breaker
    /// - Price impact checks
    /// - Fee calculation
    /// - Volume tracking
    pub fn execute_trade(
        ctx: Context<contexts::ExecuteTrade>,
        amount_in: u64,
        minimum_amount_out: u64,
    ) -> Result<TradeOutcome> {
        validate_token_program!(ctx.accounts.token_program);
        
        let state = &mut ctx.accounts.pool_state;
        let current_time = current_unix_ts()?;

        // Validate trade parameters
        validation::validate_trade_parameters(state, amount_in, current_time)?;

        // Validate token accounts
        state.check_token_mint(&ctx.accounts.token_mint)?;
        state.check_token_account(&ctx.accounts.buyer_token_account, &state.token_mint)?;
        state.check_token_account(&ctx.accounts.pool_token_account, &state.token_mint)?;

        // Calculate fee and amount out
        let (fee_amount, fee_mode) = state.calculate_fee(amount_in, current_time as i64)?;
        let amount_out = amount_in
            .checked_sub(fee_amount)
            .ok_or(ErrorCode::Overflow)?;

        let price_impact = state.calculate_price_impact(amount_in, ctx.accounts.pool_token_account.amount)?;

        // Validate against minimum amount out
        require!(
            amount_out >= minimum_amount_out,
            ErrorCode::SlippageExceeded,
            "Amount out {} is less than minimum {}",
            amount_out,
            minimum_amount_out
        );

        // Validate against pool liquidity
        require!(
            amount_out <= ctx.accounts.pool_token_account.amount,
            ErrorCode::InsufficientPoolBalance,
            "Amount out {} exceeds pool balance {}",
            amount_out,
            ctx.accounts.pool_token_account.amount
        );

        // Transfer tokens from buyer to pool
        let cpi_context = with_pool_signer(
            &ctx.program_id,
            state,
            &[ctx.accounts.pool_authority.to_account_info()],
        )?;

        token::transfer(
            cpi_context,
            amount_in,
        )?;

        // Update pool state
        state.total_fees_collected = state.total_fees_collected.saturating_add(fee_amount);
        state.trade_settings.last_trade_time = current_time;
        state.rate_limit.count = state.rate_limit.count.saturating_add(1);
        state.volume.volume_24h = state.volume.volume_24h.saturating_add(amount_in);

        // Emit trade event
        state.emit_trade_executed(
            &ctx.accounts.buyer.key(),
            amount_in,
            amount_out,
            fee_amount,
            fee_mode,
            current_time as i64,
        );

        Ok(TradeOutcome {
            amount_out,
            fee_amount,
            fee_mode,
            price_impact,
            timestamp: current_time as i64,
        })
    }

    /// Calculate fee based on trade timing and volume
    ///
    /// This function determines the appropriate fee to charge based on:
    /// 1. Whether the trade is within the early trade window
    /// 2. The current 24h volume and applicable fee tier
    /// 3. Returns both the fee amount and the fee mode for tracking
    fn calculate_fee(pool_state: &PoolState, amount_in: u64, current_time: i64) -> Result<(u64, u8)> {
        // Early trade fee if within protection window
        if current_time - pool_state.pool_start_time as i64 <= pool_state.trade_settings.early_trade_window_seconds as i64 {
            let fee = amount_in
                .checked_mul(pool_state.trade_settings.early_trade_fee_bps)
                .ok_or(ErrorCode::Overflow)?
                .checked_div(10000)
                .ok_or(ErrorCode::Overflow)?;
            
            // Use default fee if configured, otherwise minimum fee
            let effective_fee = if fee == 0 {
                pool_state.default_fee_bps
                    .map(|bps| amount_in.checked_mul(bps).ok_or(ErrorCode::Overflow)?.checked_div(10000).ok_or(ErrorCode::Overflow)?)
                    .unwrap_or(MINIMUM_FEE)
            } else {
                fee.max(MINIMUM_FEE)
            };
            
            return Ok((effective_fee, FEE_MODE_EARLY_TRADE));
        }

        // Find applicable fee tier based on volume
        for tier in &pool_state.fee_tiers {
            if pool_state.volume.volume_24h <= tier.volume_threshold {
                let fee = amount_in
                    .checked_mul(tier.fee_bps)
                    .ok_or(ErrorCode::Overflow)?
                    .checked_div(10000)
                    .ok_or(ErrorCode::Overflow)?;
                
                // Use default fee if configured, otherwise minimum fee
                let effective_fee = if fee == 0 {
                    pool_state.default_fee_bps
                        .map(|bps| amount_in.checked_mul(bps).ok_or(ErrorCode::Overflow)?.checked_div(10000).ok_or(ErrorCode::Overflow)?)
                        .unwrap_or(MINIMUM_FEE)
                } else {
                    fee.max(MINIMUM_FEE)
                };
                
                return Ok((effective_fee, FEE_MODE_TIER_BASED));
            }
        }

        // Use default fee if configured, otherwise minimum fee
        let fallback_fee = pool_state.default_fee_bps
            .map(|bps| amount_in.checked_mul(bps).ok_or(ErrorCode::Overflow)?.checked_div(10000).ok_or(ErrorCode::Overflow)?)
            .unwrap_or(MINIMUM_FEE);

        Ok((fallback_fee, FEE_MODE_NONE))
    }

    /// Calculate price impact of a trade
    ///
    /// This function calculates the price impact of a trade in basis points,
    /// taking into account token decimals for accurate calculation.
    fn calculate_price_impact(amount_in: u64, pool_balance: u64) -> Result<u64> {
        require!(pool_balance > 0, ErrorCode::InvalidPoolBalance);
        amount_in
            .checked_mul(10000)
            .ok_or(ErrorCode::Overflow)?
            .checked_div(pool_balance)
            .ok_or(ErrorCode::Overflow)
    }

    /// Blacklist a trader to prevent them from trading
    ///
    /// This function allows the admin to blacklist a trader with:
    /// - Admin must be a signer
    /// - Trader cannot be already blacklisted
    /// - Trader cannot be the admin or emergency admin
    pub fn blacklist_trader(ctx: Context<contexts::ManageBlacklist>, trader: Pubkey) -> Result<()> {
        let pool_state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;
        
        // Add reentrancy protection
        let _guard = ReentrancyGuard::new(pool_state)?;
        
        utils::process_blacklist_operations(
            pool_state,
            vec![trader],
            BlacklistOperation::Add,
            current_time,
        )
    }

    /// Remove a trader from the blacklist
    ///
    /// This function allows the admin to remove a trader from the blacklist with:
    /// - Admin must be a signer
    /// - Trader must be currently blacklisted
    pub fn remove_from_blacklist(ctx: Context<contexts::ManageBlacklist>, trader: Pubkey) -> Result<()> {
        let pool_state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;
        
        // Add reentrancy protection
        let _guard = ReentrancyGuard::new(pool_state)?;
        
        utils::process_blacklist_operations(
            pool_state,
            vec![trader],
            BlacklistOperation::Remove,
            current_time,
        )
    }

    /// Batch blacklist multiple traders efficiently
    ///
    /// This function allows the admin to blacklist multiple traders in a single transaction with:
    /// - Admin must be a signer
    /// - Maximum of 50 traders per batch
    /// - Each trader must not be already blacklisted
    /// - No trader can be the admin or emergency admin
    pub fn batch_blacklist_traders(ctx: Context<contexts::ManageBlacklist>, traders: Vec<Pubkey>) -> Result<()> {
        let pool_state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;
        
        utils::process_blacklist_operations(
            pool_state,
            traders,
            BlacklistOperation::Add,
            current_time,
        )
    }

    /// Batch unblacklist multiple traders efficiently
    ///
    /// NEW: Added to allow the admin to remove multiple traders from the blacklist in a single transaction.
    /// - Admin must be a signer
    /// - Maximum of 50 traders per batch
    /// - Each trader must be currently blacklisted
    pub fn batch_unblacklist_traders(ctx: Context<contexts::ManageBlacklist>, traders: Vec<Pubkey>) -> Result<()> {
        let pool_state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;
        
        utils::process_blacklist_operations(
            pool_state,
            traders,
            BlacklistOperation::Remove,
            current_time,
        )
    }

    /// Withdraw collected fees from the pool
    ///
    /// This function allows the admin to withdraw collected fees with:
    /// - Admin must be a signer
    /// - Fees must be available to withdraw
    /// - Reentrancy protection
    pub fn withdraw_fees(ctx: Context<contexts::WithdrawFees>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate token accounts
        state.check_token_mint(&ctx.accounts.token_mint)?;
        state.check_token_account(&ctx.accounts.admin_token_account, &state.token_mint)?;
        state.check_token_account(&ctx.accounts.pool_token_account, &state.token_mint)?;

        // Validate fees available
        validate_condition!(state.total_fees_collected > 0, ErrorCode::NoFeesAvailable);

        // Transfer fees from pool to admin
        let cpi_ctx = with_pool_signer(
            &crate::ID,
            state,
            &[ctx.accounts.pool_token_account.to_account_info(), ctx.accounts.admin_token_account.to_account_info()],
        )?;

        token::transfer(
            cpi_ctx,
            state.total_fees_collected,
        )?;

        // Update pool state
        state.total_fees_collected = 0;
        state.last_update = current_time;

        // Emit event
        emit!(FeesWithdrawn {
            pool: state.key(),
            admin_pubkey: state.admin,
            amount: state.total_fees_collected,
            ts: current_time as i64,
        });

        Ok(())
    }

    /// Lock fee tiers to prevent further changes
    ///
    /// This function allows the admin to lock fee tiers with:
    /// - Admin must be a signer
    /// - Fee tiers must not be already locked
    pub fn lock_fee_tiers(ctx: Context<contexts::LockFeeTiers>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate fee tiers not already locked
        validate_condition!(!state.fee_tiers_locked, ErrorCode::FeeTiersLocked);

        // Update pool state
        state.fee_tiers_locked = true;
        state.last_update = current_time;

        // Emit event
        emit!(FeeTiersLocked {
            pool: state.key(),
            admin_pubkey: state.admin,
            ts: current_time as i64,
        });

        Ok(())
    }

    /// Unlock fee tiers to allow future changes
    ///
    /// NEW: Added to allow the admin to unlock fee tiers with a 24-hour timelock.
    /// - Admin must be a signer
    /// - Fee tiers must be currently locked
    /// - Schedules unlock via pending_update for delayed execution
    pub fn unlock_fee_tiers(ctx: Context<contexts::AdminAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate fee tiers are locked
        validate_condition!(state.fee_tiers_locked, ErrorCode::FeeTiersNotLocked);

        // Update pool state
        state.fee_tiers_locked = false;
        state.last_update = current_time;

        // Emit event
        emit!(FeeTiersUnlockScheduled {
            pool: state.key(),
            admin_pubkey: state.admin,
            scheduled_time: current_time as i64,
        });

        Ok(())
    }

    /// Schedule a parameter update with a 24-hour timelock
    ///
    /// This function allows the admin to schedule changes to pool parameters.
    /// - Validates: admin, new fee tiers, parameter relationships
    /// - Stores: pending update with scheduled execution time
    pub fn schedule_parameter_update(
        ctx: Context<contexts::AdminAction>,
        trade_settings: Option<TradeSettingsUpdate>,
        protection_settings: Option<ProtectionSettingsUpdate>,
        fee_settings: Option<FeeSettingsUpdate>,
        state_settings: Option<StateSettingsUpdate>,
    ) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate new settings if provided
        if let Some(settings) = &trade_settings {
            validate_parameter!(
                settings.max_trade_size_bps,
                settings.min_trade_size,
                u64::MAX,
                ErrorCode::InvalidParameterRelationship
            );
        }

        if let Some(settings) = &protection_settings {
            validate_parameter!(
                settings.max_price_impact_bps,
                0,
                10000,
                ErrorCode::PriceImpactTooHigh
            );
        }

        if let Some(settings) = &fee_settings {
            if let Some(fee_tiers) = &settings.fee_tiers {
                validation::validate_fee_parameters(state, fee_tiers)?;
            }
        }

        // Create pending update
        state.pending_update = Some(PendingUpdate {
            scheduled_time: current_time + 86400, // 24 hour timelock
            trade_settings,
            protection_settings,
            fee_settings,
            state_settings,
        });

        emit!(ParameterUpdateScheduled {
            pool: state.key(),
            admin_pubkey: state.admin,
            scheduled_time: current_time + 86400,
        });

        Ok(())
    }

    /// Cancel a scheduled parameter update
    ///
    /// This function allows the admin to cancel a pending parameter update before the timelock expires.
    /// - Validates: admin, presence of pending update
    /// - Clears: pending update
    pub fn cancel_parameter_update(ctx: Context<contexts::AdminAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = current_unix_ts()?;

        // Validate admin
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Take the pending update
        let pending_update = state.pending_update.take().ok_or_else(|| {
            error!(ErrorCode::NoPendingUpdate, "No pending update available")
        })?;

        // Emit detailed cancellation event
        emit!(ParameterUpdateCancelled {
            pool: state.key(),
            admin_pubkey: ctx.accounts.admin.key(),
            ts: current_time as i64,
            trade_settings: pending_update.trade_settings,
            protection_settings: pending_update.protection_settings,
            fee_settings: pending_update.fee_settings,
            state_settings: pending_update.state_settings,
        });

        state.last_update = current_time;
        Ok(())
    }

    /// Apply a scheduled parameter update
    ///
    /// This function applies a pending parameter update after the timelock expires.
    /// - Validates: admin, timelock, parameter relationships
    /// - Updates: pool state with new parameters
    pub fn apply_parameter_update(ctx: Context<contexts::AdminAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = current_unix_ts()?;

        // Validate admin and timelock
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;
        validate_condition!(
            state.pending_update.is_some(),
            ErrorCode::NoPendingUpdate,
            "No pending update available"
        );

        let pending_update = state.pending_update.as_ref().unwrap();
        validate_condition!(
            current_time >= pending_update.scheduled_time,
            ErrorCode::TimelockNotExpired,
            "Timelock not yet expired"
        );

        // Apply updates and emit events
        if let Some(trade_settings) = &pending_update.trade_settings {
            state.trade_settings.early_trade_fee_bps = trade_settings.early_trade_fee_bps;
            state.trade_settings.early_trade_window_seconds = trade_settings.early_trade_window_seconds;
            state.trade_settings.max_size_bps = trade_settings.max_trade_size_bps;
            state.trade_settings.min_size = trade_settings.min_trade_size;
            state.trade_settings.cooldown_seconds = trade_settings.cooldown_seconds;

            emit!(TradeSettingsUpdated {
                pool: state.key(),
                admin_pubkey: ctx.accounts.admin.key(),
                early_trade_fee_bps: trade_settings.early_trade_fee_bps,
                early_trade_window_seconds: trade_settings.early_trade_window_seconds,
                max_trade_size_bps: trade_settings.max_trade_size_bps,
                min_trade_size: trade_settings.min_trade_size,
                cooldown_seconds: trade_settings.cooldown_seconds,
                ts: current_time as i64,
            });
        }

        if let Some(protection_settings) = &pending_update.protection_settings {
            state.volume.max_daily = protection_settings.max_daily_volume;
            state.protection.max_price_impact_bps = protection_settings.max_price_impact_bps;
            state.circuit_breaker.threshold = protection_settings.circuit_breaker_threshold;
            state.circuit_breaker.window = protection_settings.circuit_breaker_window;
            state.circuit_breaker.cooldown = protection_settings.circuit_breaker_cooldown;
            state.rate_limit.window = protection_settings.rate_limit_window;
            state.rate_limit.max = protection_settings.rate_limit_max;

            emit!(ProtectionSettingsUpdated {
                pool: state.key(),
                admin_pubkey: ctx.accounts.admin.key(),
                max_daily_volume: protection_settings.max_daily_volume,
                max_price_impact_bps: protection_settings.max_price_impact_bps,
                circuit_breaker_threshold: protection_settings.circuit_breaker_threshold,
                circuit_breaker_window: protection_settings.circuit_breaker_window,
                circuit_breaker_cooldown: protection_settings.circuit_breaker_cooldown,
                rate_limit_window: protection_settings.rate_limit_window,
                rate_limit_max: protection_settings.rate_limit_max,
                ts: current_time as i64,
            });
        }

        if let Some(fee_settings) = &pending_update.fee_settings {
            if !fee_settings.fee_tiers.is_empty() {
                state.fee_tiers = fee_settings.fee_tiers.clone();
            }
            state.fee_tiers_locked = fee_settings.fee_tiers_locked;

            emit!(FeeSettingsUpdated {
                pool: state.key(),
                admin_pubkey: ctx.accounts.admin.key(),
                fee_tiers_count: state.fee_tiers.len(),
                fee_tiers_locked: state.fee_tiers_locked,
                ts: current_time as i64,
            });
        }

        if let Some(state_settings) = &pending_update.state_settings {
            state.is_paused = state_settings.is_paused;
            state.is_emergency_paused = state_settings.is_emergency_paused;

            emit!(StateSettingsUpdated {
                pool: state.key(),
                admin_pubkey: ctx.accounts.admin.key(),
                is_paused: state_settings.is_paused,
                is_emergency_paused: state_settings.is_emergency_paused,
                ts: current_time as i64,
            });
        }

        // Clear pending update
        state.pending_update = None;
        state.last_update = current_time;

        emit!(ParametersUpdated {
            pool: state.key(),
            admin_pubkey: ctx.accounts.admin.key(),
            ts: current_time as i64,
        });

        Ok(())
    }

    /// Schedule an emergency pause with a 1-hour timelock
    ///
    /// This function allows the emergency admin to schedule a pool pause.
    /// - Validates: emergency admin
    /// - Sets: scheduled pause time
    pub fn schedule_emergency_pause(ctx: Context<contexts::EmergencyAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate emergency admin
        validate_condition!(
            ctx.accounts.emergency_admin.key() == state.emergency_admin,
            ErrorCode::InvalidEmergencyAdmin
        );

        // Validate not already paused
        validate_condition!(!state.is_emergency_paused, ErrorCode::EmergencyPaused);

        // Schedule emergency pause
        state.emergency_action_scheduled_time = current_time + 3600; // 1 hour timelock

        // Emit event
        emit!(EmergencyPauseScheduled {
            pool: state.key(),
            emergency_admin_pubkey: state.emergency_admin,
            scheduled_time: current_time + 3600,
        });

        Ok(())
    }

    /// Apply a scheduled emergency pause
    ///
    /// This function applies a scheduled pause after the timelock expires.
    /// - Validates: emergency admin, timelock
    /// - Sets: pool to emergency paused state
    pub fn apply_emergency_pause(ctx: Context<contexts::EmergencyAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate emergency admin
        validate_condition!(
            ctx.accounts.emergency_admin.key() == state.emergency_admin,
            ErrorCode::InvalidEmergencyAdmin
        );

        // Validate timelock has expired
        validate_condition!(
            current_time >= state.emergency_action_scheduled_time,
            ErrorCode::TimelockNotExpired
        );

        // Apply emergency pause
        state.is_emergency_paused = true;
        state.last_update = current_time;

        // Emit event
        emit!(EmergencyPaused {
            pool: state.key(),
            emergency_admin_pubkey: state.emergency_admin,
            ts: current_time as i64,
        });

        Ok(())
    }

    /// Schedule an emergency resume with a 1-hour timelock
    ///
    /// This function allows the emergency admin to schedule a pool resume.
    /// - Validates: emergency admin
    /// - Sets: scheduled resume time
    pub fn schedule_emergency_resume(ctx: Context<contexts::EmergencyAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate emergency admin
        validate_condition!(
            ctx.accounts.emergency_admin.key() == state.emergency_admin,
            ErrorCode::InvalidEmergencyAdmin
        );

        // Validate is paused
        validate_condition!(state.is_emergency_paused, ErrorCode::PoolNotPaused);

        // Schedule emergency resume
        state.emergency_action_scheduled_time = current_time + 3600; // 1 hour timelock

        // Emit event
        emit!(EmergencyResumeScheduled {
            pool: state.key(),
            emergency_admin_pubkey: state.emergency_admin,
            scheduled_time: current_time + 3600,
        });

        Ok(())
    }

    /// Apply a scheduled emergency resume
    ///
    /// This function applies a scheduled resume after the timelock expires.
    /// - Validates: emergency admin, timelock
    /// - Sets: pool to non-emergency paused state
    pub fn apply_emergency_resume(ctx: Context<contexts::EmergencyAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate emergency admin
        validate_condition!(
            ctx.accounts.emergency_admin.key() == state.emergency_admin,
            ErrorCode::InvalidEmergencyAdmin
        );

        // Validate timelock has expired
        validate_condition!(
            current_time >= state.emergency_action_scheduled_time,
            ErrorCode::TimelockNotExpired
        );

        // Apply emergency resume
        state.is_emergency_paused = false;
        state.last_update = current_time;

        // Emit event
        emit!(EmergencyResumed {
            pool: state.key(),
            emergency_admin_pubkey: state.emergency_admin,
            ts: current_time as i64,
        });

        Ok(())
    }

    /// Reset the circuit breaker
    ///
    /// This function allows the admin to reset the circuit breaker after its cooldown.
    /// - Validates: admin, timestamp, cooldown
    /// - Resets: circuit breaker and 24h volume
    pub fn reset_circuit_breaker(ctx: Context<contexts::AdminAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate cooldown has expired
        validate_condition!(
            current_time >= state.circuit_breaker.last_trigger + state.circuit_breaker.cooldown,
            ErrorCode::CircuitBreakerCooldown
        );

        // Reset circuit breaker
        state.circuit_breaker.last_trigger = 0;
        state.last_update = current_time;

        // Emit event
        emit!(CircuitBreakerReset {
            pool: state.key(),
            admin_pubkey: state.admin,
            ts: current_time as i64,
        });

        Ok(())
    }

    /// Update the pool admin with cooldown protection
    ///
    /// This function allows changing the pool admin with the following protections:
    /// - 24-hour cooldown between admin changes
    /// - New admin must be different from current and emergency admin
    /// - Current admin must be a signer
    pub fn update_admin(ctx: Context<contexts::AdminAction>, new_admin: Pubkey) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate new admin
        validate_condition!(
            new_admin != state.admin && new_admin != state.emergency_admin,
            ErrorCode::InvalidNewAdmin
        );

        // Update admin
        let old_admin = state.admin;
        state.admin = new_admin;
        state.last_admin_update = current_time;
        state.last_update = current_time;

        // Emit event
        emit!(AdminUpdated {
            pool: state.key(),
            old_admin_pubkey: old_admin,
            new_admin_pubkey: new_admin,
            ts: current_time as i64,
        });

        Ok(())
    }

    /// Reset the pending update
    pub fn reset_pending_update(ctx: Context<contexts::AdminAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Validate pending update exists
        validate_condition!(state.pending_update.is_some(), ErrorCode::NoPendingUpdate);

        // Reset pending update
        state.pending_update = None;
        state.last_update = current_time;

        // Emit event
        emit!(ParameterUpdateCancelled {
            pool: state.key(),
            admin_pubkey: state.admin,
            scheduled_time: current_time as i64,
            trade_settings: state.pending_update.as_ref().and_then(|u| u.trade_settings.clone()),
            protection_settings: state.pending_update.as_ref().and_then(|u| u.protection_settings.clone()),
            fee_settings: state.pending_update.as_ref().and_then(|u| u.fee_settings.clone()),
            state_settings: state.pending_update.as_ref().and_then(|u| u.state_settings.clone()),
            ts: current_time as i64,
        });

        Ok(())
    }

    /// Toggle the pool pause state
    pub fn toggle_pause(ctx: Context<contexts::AdminAction>) -> Result<()> {
        let state = &mut ctx.accounts.pool_state;
        let current_time = Clock::get()?.unix_timestamp as u64;

        // Validate admin and check cooldown
        validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

        // Toggle pause state
        state.is_paused = !state.is_paused;
        state.last_update = current_time;

        // Emit event
        if state.is_paused {
            emit!(PoolPaused {
                pool: state.key(),
                admin_pubkey: state.admin,
                ts: current_time as i64,
            });
        } else {
            emit!(PoolResumed {
                pool: state.key(),
                admin_pubkey: state.admin,
                ts: current_time as i64,
            });
        }

        Ok(())
    }

    // Add fee tier validation function
    pub fn validate_fee_tiers(fee_tiers: &[FeeTier]) -> Result<()> {
        require!(!fee_tiers.is_empty(), ErrorCode::InvalidFeeTier);
        require!(fee_tiers.len() <= MAX_FEE_TIERS, ErrorCode::TooManyFeeTiers);

        // Check for duplicate thresholds
        let mut thresholds: Vec<u64> = fee_tiers.iter().map(|tier| tier.volume_threshold).collect();
        thresholds.sort_unstable();
        thresholds.dedup();
        require!(thresholds.len() == fee_tiers.len(), ErrorCode::DuplicateFeeTierThreshold);

        // Validate fee ranges and spacing
        for tier in fee_tiers {
            require!(tier.fee_bps >= MINIMUM_FEE, ErrorCode::FeeTooLow);
            require!(tier.fee_bps <= MAX_TIER_FEE_BPS, ErrorCode::FeeTooHigh);
        }

        // Check for proper spacing between thresholds
        for i in 1..fee_tiers.len() {
            let spacing = fee_tiers[i].volume_threshold
                .checked_sub(fee_tiers[i - 1].volume_threshold)
                .ok_or(ErrorCode::Overflow)?;
            require!(spacing >= MIN_FEE_TIER_SPACING_BPS, ErrorCode::InvalidFeeTierSpacing);
        }

        Ok(())
    }
}

// Move account contexts to a separate module
mod contexts {
    use super::*;

    /// Context for initializing a new pool
    /// 
    /// # Accounts
    /// * `pool_state` - The pool state account to initialize
    /// * `admin` - The admin account that will own the pool
    /// * `token_mint` - The token mint for the pool
    /// * `system_program` - Required for account creation
    /// * `token_program` - Required for token operations
    /// * `rent` - Required for account creation
    #[derive(Accounts)]
    pub struct InitializePool<'info> {
        #[account(
            init,
            payer = admin,
            space = PoolState::calculate_space(),
            seeds = [b"pool_state", admin.key().as_ref()],
            bump
        )]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub admin: Signer<'info>,
        #[account(mut)]
        pub token_mint: Account<'info, Mint>,
        pub system_program: Program<'info, System>,
        pub token_program: Program<'info, Token>,
        pub rent: Sysvar<'info, Rent>,
    }

    /// Context for adding liquidity to the pool
    /// 
    /// # Accounts
    /// * `pool_state` - The pool state account
    /// * `admin` - The admin account that owns the pool
    /// * `admin_token_account` - The admin's token account
    /// * `pool_token_account` - The pool's token account
    /// * `pool_authority` - The pool's authority PDA
    /// * `token_program` - Required for token operations
    #[derive(Accounts)]
    pub struct AddLiquidity<'info> {
        #[account(mut)]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub admin: Signer<'info>,
        #[account(mut)]
        pub admin_token_account: Account<'info, TokenAccount>,
        #[account(mut)]
        pub pool_token_account: Account<'info, TokenAccount>,
        #[account(
            seeds = [b"pool_authority", pool_state.key().as_ref()],
            bump
        )]
        pub pool_authority: AccountInfo<'info>,
        pub token_program: Program<'info, Token>,
    }

    #[derive(Accounts)]
    pub struct ExecuteTrade<'info> {
        #[account(mut)]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub buyer: Signer<'info>,
        #[account(mut)]
        pub buyer_token_account: Account<'info, TokenAccount>,
        #[account(mut)]
        pub pool_token_account: Account<'info, TokenAccount>,
        #[account(
            seeds = [b"pool_authority", pool_state.key().as_ref()],
            bump
        )]
        pub pool_authority: AccountInfo<'info>,
        #[account(
            constraint = token_mint.key() == pool_state.token_mint
        )]
        pub token_mint: Account<'info, Mint>,
        pub token_program: Program<'info, Token>,
    }

    #[derive(Accounts)]
    pub struct ManageBlacklist<'info> {
        #[account(mut)]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub admin: Signer<'info>,
        /// CHECK: This is the reentrancy guard PDA
        #[account(
            seeds = [b"reentrancy_guard", pool_state.key().as_ref()],
            bump,
            constraint = reentrancy_guard.to_account_info().owner == program_id
        )]
        pub reentrancy_guard: UncheckedAccount<'info>,
    }

    #[derive(Accounts)]
    pub struct AdminAction<'info> {
        #[account(mut)]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub admin: Signer<'info>,
        /// CHECK: This is the reentrancy guard PDA
        #[account(
            seeds = [b"reentrancy_guard", pool_state.key().as_ref()],
            bump,
            constraint = reentrancy_guard.to_account_info().owner == program_id
        )]
        pub reentrancy_guard: UncheckedAccount<'info>,
    }

    #[derive(Accounts)]
    pub struct WithdrawFees<'info> {
        #[account(mut)]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub admin: Signer<'info>,
        #[account(mut)]
        pub pool_token_account: Account<'info, TokenAccount>,
        #[account(mut)]
        pub admin_token_account: Account<'info, TokenAccount>,
        pub pool_authority: AccountInfo<'info>,
        pub token_program: Program<'info, Token>,
    }

    #[derive(Accounts)]
    pub struct LockFeeTiers<'info> {
        #[account(mut)]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub admin: Signer<'info>,
    }

    #[derive(Accounts)]
    pub struct EmergencyAction<'info> {
        #[account(mut)]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub emergency_admin: Signer<'info>,
    }

    #[derive(Accounts)]
    pub struct SimulateTrade<'info> {
        pub pool_state: Account<'info, PoolState>,
    }

    #[derive(Accounts)]
    pub struct WithdrawCollectedFees<'info> {
        #[account(mut)]
        pub pool_state: Account<'info, PoolState>,
        #[account(mut)]
        pub admin: Signer<'info>,
        #[account(mut)]
        pub pool_token_account: Account<'info, TokenAccount>,
        #[account(mut)]
        pub admin_token_account: Account<'info, TokenAccount>,
        #[account(
            seeds = [b"pool_authority", pool_state.key().as_ref()],
            bump
        )]
        pub pool_authority: AccountInfo<'info>,
        pub token_program: Program<'info, Token>,
    }
}

// Add helper function for PDA derivation with proper error handling
pub fn derive_pool_authority(pool_state: &Pubkey, program_id: &Pubkey) -> Result<(Pubkey, u8)> {
    Pubkey::find_program_address(
        &[b"pool_authority", pool_state.as_ref()],
        program_id,
    ).ok_or(ErrorCode::InvalidPoolAuthority)
}

// Add helper function for CPI context with proper error handling
pub fn with_pool_signer<'info>(
    program_id: &Pubkey,
    pool_state: &Account<'info, PoolState>,
    remaining_accounts: &[AccountInfo<'info>],
) -> Result<CpiContext<'_, '_, '_, 'info, TokenTransfer>> {
    let (pool_authority, bump) = derive_pool_authority(&pool_state.key(), program_id)?;
    
    let seeds = &[
        b"pool_authority".as_ref(),
        pool_state.key().as_ref(),
        &[bump],
    ];
    
    Ok(CpiContext::new_with_signer(
        remaining_accounts[0].clone(),
        TokenTransfer {
            from: remaining_accounts[1].clone(),
            to: remaining_accounts[2].clone(),
            authority: pool_authority,
        },
        &[seeds],
    ))
}

#[account]
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, Default)]
pub struct PoolState {
    pub version: u8,
    pub migration_flag: bool,
    pub is_initialized: bool,
    pub admin: Pubkey,
    pub emergency_admin: Pubkey,
    pub token_mint: Pubkey,
    pub token_decimals: u8,
    pub total_fees_collected: u64,
    pub total_liquidity: u64,
    pub is_paused: bool,
    pub is_emergency_paused: bool,
    pub is_finalized: bool,
    pub pool_start_time: u64,
    pub last_update: u64,
    pub last_admin_update: u64,
    pub last_fee_withdrawal: u64, // Track last fee withdrawal
    pub emergency_action_scheduled_time: u64,
    pub pending_update: Option<PendingUpdate>,
    pub trade_settings: TradeSettings,
    pub rate_limit: RateLimitSettings,
    pub circuit_breaker: CircuitBreakerSettings,
    pub volume: VolumeSettings,
    pub protection: ProtectionSettings,
    pub fee_tiers: Vec<FeeTier>,
    pub fee_tiers_locked: bool,
    pub default_fee_bps: Option<u64>,
    pub trader_blacklist: Vec<Pubkey>,
    pub instruction_counter: u64,
    pub bump: u8, // Store PDA bump
    pub pool_id: [u8; 32], // Unique pool identifier
}

impl PoolState {
    pub fn calculate_space() -> usize {
        // Calculate space for base struct
        let base_size = std::mem::size_of::<PoolState>();
        
        // Calculate space for dynamic fields
        let pending_update_size = PendingUpdate::default().try_to_vec().unwrap().len();
        let fee_tiers_size = MAX_FEE_TIERS * std::mem::size_of::<FeeTier>();
        let blacklist_size = MAX_BLACKLIST_SIZE * std::mem::size_of::<Pubkey>();
        
        // Add 8 bytes for discriminator
        base_size + pending_update_size + fee_tiers_size + blacklist_size + 8
    }

    pub fn toggle_pause(&mut self, current_time: u64) -> Result<()> {
        self.is_paused = !self.is_paused;
        self.last_update = current_time;

        if self.is_paused {
            emit!(PoolPaused {
                pool: self.key(),
                admin_pubkey: self.admin,
                ts: current_time as i64,
            });
        } else {
            emit!(PoolResumed {
                pool: self.key(),
                admin_pubkey: self.admin,
                ts: current_time as i64,
            });
        }

        Ok(())
    }

    pub fn toggle_emergency_pause(&mut self, current_time: u64) -> Result<()> {
        self.is_emergency_paused = !self.is_emergency_paused;
        self.last_update = current_time;

        if self.is_emergency_paused {
            emit!(EmergencyPaused {
                pool: self.key(),
                emergency_admin_pubkey: self.emergency_admin,
                ts: current_time as i64,
            });
        } else {
            emit!(EmergencyResumed {
                pool: self.key(),
                emergency_admin_pubkey: self.emergency_admin,
                ts: current_time as i64,
            });
        }

        Ok(())
    }

    pub fn decay_volume(&mut self, current_time: u64) -> Result<()> {
        let hours_passed = current_time
            .checked_sub(self.volume.last_decay)
            .ok_or_else(|| {
                error!(ErrorCode::InvalidTimestamp, "Failed to calculate hours passed: {} - {}", 
                    current_time, self.volume.last_decay)
            })?
            .checked_div(3600)
            .ok_or_else(|| {
                error!(ErrorCode::Overflow, "Hours calculation overflow: {} / 3600", 
                    current_time - self.volume.last_decay)
            })?;

        if hours_passed > 0 {
            let decay_factor = 100u64.saturating_sub(hours_passed.min(24));
            let new_volume = self.volume.volume_24h
                .saturating_mul(decay_factor)
                .checked_div(100)
                .ok_or_else(|| {
                    error!(ErrorCode::Overflow, "Volume decay calculation overflow: {} * {} / 100", 
                        self.volume.volume_24h, decay_factor)
                })?;

            self.volume.volume_24h = new_volume;
            self.volume.last_decay = current_time;
        }

        Ok(())
    }

    pub fn reset_rate_limit(&mut self, current_time: u64) -> Result<()> {
        let old_count = self.rate_limit.count;
        self.rate_limit.count = 0;
        self.rate_limit.last_reset = current_time;

        emit!(RateLimitReset {
            pool: self.key(),
            old_count,
            new_count: 0,
            ts: current_time as i64,
        });

        Ok(())
    }

    pub fn pause_pool(&mut self, current_time: u64) -> Result<()> {
        require!(!self.is_paused, ErrorCode::PoolPaused);
        self.is_paused = true;
        self.last_update = current_time;

        emit!(PoolPaused {
            pool: self.key(),
            admin_pubkey: self.admin,
            ts: current_time as i64,
        });

        Ok(())
    }

    pub fn resume_pool(&mut self, current_time: u64) -> Result<()> {
        require!(self.is_paused, ErrorCode::PoolNotPaused);
        self.is_paused = false;
        self.last_update = current_time;

        emit!(PoolResumed {
            pool: self.key(),
            admin_pubkey: self.admin,
            ts: current_time as i64,
        });

        Ok(())
    }

    pub fn check_token_mint(&self, mint: &Account<Mint>) -> Result<()> {
        validate_condition!(mint.key() == self.token_mint, ErrorCode::InvalidTokenMint);
        validate_condition!(mint.decimals == self.token_decimals, ErrorCode::InvalidTokenDecimals);
        validate_condition!(mint.freeze_authority.is_none(), ErrorCode::TokenMintHasFreezeAuthority);
        Ok(())
    }

    pub fn check_token_account(&self, account: &Account<TokenAccount>, mint: &Pubkey) -> Result<()> {
        validate_condition!(account.mint == *mint, ErrorCode::InvalidTokenAccount);
        validate_condition!(!account.is_delegated(), ErrorCode::TokenAccountDelegated);
        Ok(())
    }

    pub fn emit_liquidity_added(&self, admin: &Pubkey, amount: u64, ts: i64) {
        emit!(LiquidityAdded {
            pool: self.key(),
            admin_pubkey: *admin,
            amount,
            ts,
        });
    }

    pub fn emit_liquidity_removed(&self, admin: &Pubkey, amount: u64, ts: i64) {
        emit!(LiquidityRemoved {
            pool: self.key(),
            admin_pubkey: *admin,
            amount,
            ts,
        });
    }

    pub fn emit_trade_executed(&self, buyer: &Pubkey, amount_in: u64, amount_out: u64, fee_amount: u64, fee_mode: u8, ts: i64) {
        emit!(TradeExecuted {
            pool: self.key(),
            buyer_pubkey: *buyer,
            amount_in,
            amount_out,
            fee_amount,
            fee_mode,
            ts,
            token_mint: self.token_mint,
        });
    }

    /// Calculates the price impact of a trade
    /// 
    /// # Arguments
    /// * `amount_in` - The amount of tokens being traded
    /// * `pool_balance` - The current pool balance
    /// 
    /// # Returns
    /// * `Result<u64>` - The price impact in basis points
    pub fn calculate_price_impact(&self, amount_in: u64, pool_balance: u64) -> Result<u64> {
        if pool_balance == 0 {
            return Ok(0);
        }

        // Calculate price impact in basis points
        let impact = amount_in
            .checked_mul(10000)
            .ok_or(ErrorCode::Overflow)?
            .checked_div(pool_balance)
            .ok_or(ErrorCode::Overflow)?;

        Ok(impact)
    }

    /// Enforces minimum fee requirements and handles edge cases
    /// 
    /// # Arguments
    /// * `fee` - The calculated fee amount
    /// 
    /// # Returns
    /// * `Result<u64>` - The enforced minimum fee
    pub fn enforce_min_fee(&self, fee: u64) -> Result<u64> {
        // Ensure fee is at least MINIMUM_FEE to prevent zero-fee edge cases
        let min_fee = fee.max(MINIMUM_FEE);
        
        // Check for overflow after max operation
        if min_fee < fee {
            return Err(ErrorCode::Overflow.into());
        }

        Ok(min_fee)
    }

    pub fn calculate_fee(&self, amount_in: u64, current_time: i64) -> Result<(u64, u8)> {
        // Check if we're in early trade window
        let pool_age = current_time
            .checked_sub(self.pool_start_time as i64)
            .ok_or_else(|| {
                error!(ErrorCode::InvalidTimestamp, "Failed to calculate pool age: {} - {}", 
                    current_time, self.pool_start_time)
            })?;

        if pool_age < self.trade_settings.early_trade_window_seconds as i64 {
            // Apply early trade fee
            let fee = self.trade_settings.early_trade_fee_bps
                .checked_mul(amount_in)
                .ok_or_else(|| {
                    error!(ErrorCode::Overflow, "Fee calculation overflow: {} * {}", 
                        self.trade_settings.early_trade_fee_bps, amount_in)
                })?
                .checked_div(10000)
                .ok_or_else(|| {
                    error!(ErrorCode::Overflow, "Fee calculation division overflow: {} / 10000", 
                        self.trade_settings.early_trade_fee_bps * amount_in)
                })?;

            // Ensure minimum fee
            let fee = self.enforce_min_fee(fee)?;
            return Ok((fee, FEE_MODE_EARLY_TRADE));
        }

        // Find applicable fee tier
        for tier in &self.fee_tiers {
            if self.volume.volume_24h <= tier.volume_threshold {
                let fee = tier.fee_bps
                    .checked_mul(amount_in)
                    .ok_or(ErrorCode::Overflow)?
                    .checked_div(10000)
                    .ok_or(ErrorCode::Overflow)?;

                // Ensure minimum fee
                let fee = self.enforce_min_fee(fee)?;
                return Ok((fee, FEE_MODE_TIER_BASED));
            }
        }

        // Use default fee if no tier applies
        let default_fee_bps = self.default_fee_bps.unwrap_or(MINIMUM_FEE_BPS);
        let fee = default_fee_bps
            .checked_mul(amount_in)
            .ok_or(ErrorCode::Overflow)?
            .checked_div(10000)
            .ok_or(ErrorCode::Overflow)?;

        // Ensure minimum fee
        let fee = self.enforce_min_fee(fee)?;
        Ok((fee, FEE_MODE_NONE))
    }

    pub fn schedule_emergency_pause(&mut self, current_time: u64) -> Result<()> {
        let scheduled_time = current_time
            .checked_add(EMERGENCY_TIMELOCK_SECONDS)
            .ok_or(ErrorCode::Overflow)?;

        self.emergency_action_scheduled_time = scheduled_time;
        Ok(())
    }

    pub fn schedule_emergency_resume(&mut self, current_time: u64) -> Result<()> {
        let scheduled_time = current_time
            .checked_add(EMERGENCY_TIMELOCK_SECONDS)
            .ok_or(ErrorCode::Overflow)?;

        self.emergency_action_scheduled_time = scheduled_time;
        Ok(())
    }

    pub fn decay_volume(&mut self, current_time: u64) -> Result<()> {
        let hours_passed = current_time
            .checked_sub(self.volume.last_decay)
            .ok_or_else(|| {
                error!(ErrorCode::InvalidTimestamp, "Failed to calculate hours passed: {} - {}", 
                    current_time, self.volume.last_decay)
            })?
            .checked_div(3600)
            .ok_or_else(|| {
                error!(ErrorCode::Overflow, "Hours calculation overflow: {} / 3600", 
                    current_time - self.volume.last_decay)
            })?;

        if hours_passed > 0 {
            let decay_factor = 100u64.saturating_sub(hours_passed.min(24));
            let new_volume = self.volume.volume_24h
                .saturating_mul(decay_factor)
                .checked_div(100)
                .ok_or_else(|| {
                    error!(ErrorCode::Overflow, "Volume decay calculation overflow: {} * {} / 100", 
                        self.volume.volume_24h, decay_factor)
                })?;

            self.volume.volume_24h = new_volume;
            self.volume.last_decay = current_time;
        }

        Ok(())
    }

    pub fn validate_fee_tiers(&self, fee_tiers: &[FeeTier]) -> Result<()> {
        // Check uniqueness of volume thresholds
        let mut prev_threshold = 0;
        for tier in fee_tiers {
            validate_condition!(
                tier.volume_threshold > prev_threshold,
                ErrorCode::DuplicateFeeTierThreshold,
                "Fee tier threshold {} not strictly increasing",
                tier.volume_threshold
            );
            self.validate_fee_bounds(tier.fee_bps)?;
            prev_threshold = tier.volume_threshold;
        }
        Ok(())
    }

    pub fn validate_fee_bounds(&self, fee_bps: u64) -> Result<()> {
        validate_condition!(
            fee_bps >= MINIMUM_FEE_BPS && fee_bps <= MAXIMUM_FEE_BPS,
            ErrorCode::FeeTooLow,
            "Fee {} bps outside allowed range [{}, {}]",
            fee_bps,
            MINIMUM_FEE_BPS,
            MAXIMUM_FEE_BPS
        );
        Ok(())
    }

    pub fn is_address_forbidden(&self, address: &Pubkey) -> bool {
        address == &self.admin || 
        address == &self.emergency_admin || 
        self.trader_blacklist.contains(address)
    }

    /// Initializes a new pool state with the given parameters
    /// 
    /// # Arguments
    /// * `admin` - Public key of the pool admin
    /// * `token_mint` - Public key of the pool's token mint
    /// * `bump` - PDA bump seed
    /// 
    /// # Returns
    /// * `Result<()>` - Success or error
    pub fn initialize(&mut self, admin: &Pubkey, token_mint: &Pubkey, bump: u8) -> Result<()> {
        // Generate unique pool ID
        let pool_id = Pubkey::find_program_address(
            &[POOL_ID_SEED, admin.as_ref(), token_mint.as_ref()],
            &crate::ID,
        ).0.to_bytes();

        self.pool_id = pool_id;
        self.bump = bump;
        self.admin = *admin;
        self.token_mint = *token_mint;
        self.is_initialized = true;
        self.pool_start_time = current_unix_ts()?;
        self.last_update = current_unix_ts()?;
        Ok(())
    }

    /// Validates fee tiers before locking them
    /// 
    /// Ensures that:
    /// 1. Volume thresholds are strictly increasing
    /// 2. Fee rates are non-increasing
    /// 3. All fees are within allowed bounds
    /// 
    /// # Returns
    /// * `Result<()>` - Success or error
    pub fn validate_fee_tiers_before_lock(&self) -> Result<()> {
        if self.fee_tiers.is_empty() {
            return Ok(());
        }

        let mut prev_threshold = 0;
        let mut prev_fee = u64::MAX;

        for tier in &self.fee_tiers {
            // Check threshold ordering
            validate_condition!(
                tier.volume_threshold > prev_threshold,
                ErrorCode::InvalidFeeTier,
                "Fee tier threshold {} not strictly increasing",
                tier.volume_threshold
            );

            // Check fee ordering
            validate_condition!(
                tier.fee_bps <= prev_fee,
                ErrorCode::InvalidFeeTier,
                "Fee tier {} bps not non-increasing",
                tier.fee_bps
            );

            prev_threshold = tier.volume_threshold;
            prev_fee = tier.fee_bps;
        }

        Ok(())
    }
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeSettings {
    pub max_size_bps: u64,
    pub min_size: u64,
    pub cooldown_seconds: u64,
    pub last_trade_time: u64,
    pub early_trade_fee_bps: u64,
    pub early_trade_window_seconds: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct RateLimitSettings {
    pub window: u64,
    pub count: u32,
    pub max: u32,
    pub last_reset: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct CircuitBreakerSettings {
    pub threshold: u64,
    pub window: u64,
    pub cooldown: u64,
    pub last_trigger: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct VolumeSettings {
    pub volume_24h: u64,
    pub last_update: u64,
    pub last_decay: u64,
    pub max_daily: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct ProtectionSettings {
    pub snipe_protection_seconds: u64,
    pub max_price_impact_bps: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct FeeTier {
    /// Volume threshold for this tier (must be strictly increasing)
    pub volume_threshold: u64,
    /// Fee in basis points (must be non-increasing)
    pub fee_bps: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct PendingUpdate {
    /// When the update should be applied
    pub scheduled_time: u64,
    /// Updates to trade-related parameters
    pub trade_settings: Option<TradeSettingsUpdate>,
    /// Updates to protection mechanisms
    pub protection_settings: Option<ProtectionSettingsUpdate>,
    /// Updates to fee structure
    pub fee_settings: Option<FeeSettingsUpdate>,
    /// Updates to pool state
    pub state_settings: Option<StateSettingsUpdate>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeSettingsUpdate {
    /// Fee in basis points for early trades
    pub early_trade_fee_bps: u64,
    /// Duration in seconds for early trade window
    pub early_trade_window_seconds: u64,
    /// Maximum trade size as basis points of pool
    pub max_trade_size_bps: u64,
    /// Minimum trade size in lamports
    pub min_trade_size: u64,
    /// Cooldown period between trades in seconds
    pub cooldown_seconds: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct ProtectionSettingsUpdate {
    /// Maximum daily trading volume
    pub max_daily_volume: u64,
    /// Maximum price impact in basis points
    pub max_price_impact_bps: u64,
    /// Volume threshold for circuit breaker
    pub circuit_breaker_threshold: u64,
    /// Time window for circuit breaker in seconds
    pub circuit_breaker_window: u64,
    /// Cooldown period after circuit breaker in seconds
    pub circuit_breaker_cooldown: u64,
    /// Time window for rate limiting in seconds
    pub rate_limit_window: u64,
    /// Maximum number of trades in rate limit window
    pub rate_limit_max: u32,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct FeeSettingsUpdate {
    /// New fee tiers (if any)
    pub fee_tiers: Vec<FeeTier>,
    /// Whether fee tiers should be locked
    pub fee_tiers_locked: bool,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct StateSettingsUpdate {
    /// Whether the pool should be paused
    pub is_paused: bool,
    /// Whether the pool should be emergency paused
    pub is_emergency_paused: bool,
}

/// Emitted when a new pool is initialized
#[event]
pub struct PoolInitialized {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Unix timestamp of initialization
    pub ts: i64,
}

/// Emitted when liquidity is added to the pool
#[event]
pub struct LiquidityAdded {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Amount of liquidity added
    pub amount: u64,
    /// Unix timestamp of addition
    pub ts: i64,
}

/// Emitted when liquidity is removed from the pool
#[event]
pub struct LiquidityRemoved {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Amount of liquidity removed
    pub amount: u64,
    /// Unix timestamp of removal
    pub ts: i64,
}

/// Emitted when a trade is executed
#[event]
pub struct TradeExecuted {
    /// The pool's public key
    pub pool: Pubkey,
    /// The buyer's public key
    pub buyer_pubkey: Pubkey,
    /// Amount of tokens input
    pub amount_in: u64,
    /// Amount of tokens output
    pub amount_out: u64,
    /// Fee amount charged
    pub fee_amount: u64,
    /// Fee mode applied (0=none, 1=early, 2=tier)
    pub fee_mode: u8,
    /// Unix timestamp of trade
    pub ts: i64,
    /// The token mint's public key
    pub token_mint: Pubkey,
}

/// Emitted when rate limit is reset
#[event]
pub struct RateLimitReset {
    /// The pool's public key
    pub pool: Pubkey,
    /// Previous rate limit count
    pub old_count: u32,
    /// New rate limit count
    pub new_count: u32,
    /// Unix timestamp of reset
    pub ts: i64,
}

/// Emitted when circuit breaker is triggered
#[event]
pub struct CircuitBreakerTriggered {
    /// The pool's public key
    pub pool: Pubkey,
    /// Current 24h volume
    pub volume_24h: u64,
    /// Circuit breaker threshold
    pub threshold: u64,
    /// Unix timestamp of trigger
    pub ts: i64,
}

/// Emitted when a trader is blacklisted
#[event]
pub struct TraderBlacklisted {
    /// The pool's public key
    pub pool: Pubkey,
    /// The trader's public key
    pub trader_pubkey: Pubkey,
    /// Unix timestamp of blacklist
    pub ts: i64,
}

/// Emitted when a trader is removed from blacklist
#[event]
pub struct TraderRemovedFromBlacklist {
    /// The pool's public key
    pub pool: Pubkey,
    /// The trader's public key
    pub trader_pubkey: Pubkey,
    /// Unix timestamp of removal
    pub ts: i64,
}

/// Emitted when batch blacklist operation completes
#[event]
pub struct BatchBlacklistCompleted {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Number of traders processed
    pub count: u64,
    /// Unix timestamp of completion
    pub ts: i64,
}

/// Emitted when fees are withdrawn
#[event]
pub struct FeesWithdrawn {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Amount of fees withdrawn
    pub amount: u64,
    /// Unix timestamp of withdrawal
    pub ts: i64,
}

/// Emitted when fee tiers are locked
#[event]
pub struct FeeTiersLocked {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Unix timestamp of locking
    pub ts: i64,
}

/// Emitted when fee tiers unlock is scheduled
#[event]
pub struct FeeTiersUnlockScheduled {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Scheduled unlock timestamp
    pub scheduled_time: i64,
}

/// Emitted when parameter update is scheduled
#[event]
pub struct ParameterUpdateScheduled {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Scheduled update timestamp
    pub scheduled_time: i64,
}

/// Emitted when parameter update is cancelled
#[event]
pub struct ParameterUpdateCancelled {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Unix timestamp of cancellation
    pub ts: i64,
    /// Trade settings update
    pub trade_settings: Option<TradeSettingsUpdate>,
    /// Protection settings update
    pub protection_settings: Option<ProtectionSettingsUpdate>,
    /// Fee settings update
    pub fee_settings: Option<FeeSettingsUpdate>,
    /// State settings update
    pub state_settings: Option<StateSettingsUpdate>,
}

/// Emitted when parameters are updated
#[event]
pub struct ParametersUpdated {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Unix timestamp of update
    pub ts: i64,
}

/// Emitted when emergency pause is scheduled
#[event]
pub struct EmergencyPauseScheduled {
    /// The pool's public key
    pub pool: Pubkey,
    /// The emergency admin's public key
    pub emergency_admin_pubkey: Pubkey,
    /// Scheduled pause timestamp
    pub scheduled_time: i64,
}

/// Emitted when emergency pause is applied
#[event]
pub struct EmergencyPaused {
    /// The pool's public key
    pub pool: Pubkey,
    /// The emergency admin's public key
    pub emergency_admin_pubkey: Pubkey,
    /// Unix timestamp of pause
    pub ts: i64,
}

/// Emitted when emergency resume is scheduled
#[event]
pub struct EmergencyResumeScheduled {
    /// The pool's public key
    pub pool: Pubkey,
    /// The emergency admin's public key
    pub emergency_admin_pubkey: Pubkey,
    /// Scheduled resume timestamp
    pub scheduled_time: i64,
}

/// Emitted when emergency resume is applied
#[event]
pub struct EmergencyResumed {
    /// The pool's public key
    pub pool: Pubkey,
    /// The emergency admin's public key
    pub emergency_admin_pubkey: Pubkey,
    /// Unix timestamp of resume
    pub ts: i64,
}

/// Emitted when circuit breaker is reset
#[event]
pub struct CircuitBreakerReset {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Unix timestamp of reset
    pub ts: i64,
}

/// Emitted when admin is updated
#[event]
pub struct AdminUpdated {
    /// The pool's public key
    pub pool: Pubkey,
    /// Previous admin's public key
    pub old_admin_pubkey: Pubkey,
    /// New admin's public key
    pub new_admin_pubkey: Pubkey,
    /// Unix timestamp of update
    pub ts: i64,
}

/// Emitted when an operation fails
#[event]
pub struct OperationFailed {
    /// The pool's public key
    pub pool: Pubkey,
    /// Name of the failed operation
    pub operation: String,
    /// Reason for failure
    pub reason: String,
    /// Unix timestamp of failure
    pub ts: i64,
}

/// Emitted when freeze authority is detected
#[event]
pub struct FreezeAuthorityWarning {
    /// The pool's public key
    pub pool: Pubkey,
    /// The token mint's public key
    pub token_mint: Pubkey,
    /// Unix timestamp of warning
    pub ts: i64,
}

/// Emitted when pool is paused
#[event]
pub struct PoolPaused {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Unix timestamp of pause
    pub ts: i64,
}

/// Emitted when pool is resumed
#[event]
pub struct PoolResumed {
    /// The pool's public key
    pub pool: Pubkey,
    /// The admin's public key
    pub admin_pubkey: Pubkey,
    /// Unix timestamp of resume
    pub ts: i64,
}

/// Emitted when volume decays
#[event]
pub struct VolumeDecayed {
    /// The pool's public key
    pub pool: Pubkey,
    /// Previous 24h volume
    pub old_volume: u64,
    /// New 24h volume
    pub new_volume: u64,
    /// Number of hours passed
    pub hours_passed: u64,
    /// Unix timestamp of decay
    pub ts: i64,
}

/// Emitted when price impact is rejected
#[event]
pub struct PriceImpactRejected {
    /// The pool's public key
    pub pool: Pubkey,
    /// Amount of tokens input
    pub amount_in: u64,
    /// Calculated price impact
    pub price_impact: u64,
    /// Maximum allowed price impact
    pub max_allowed: u64,
    /// Unix timestamp of rejection
    pub ts: i64,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Unauthorized access: caller is not the admin or emergency admin")]
    Unauthorized, // Used in: initialize_pool, add_liquidity, remove_liquidity, execute_trade

    #[msg("Invalid token program: expected Token program")]
    InvalidTokenProgram, // Used in: initialize_pool, add_liquidity, remove_liquidity, execute_trade

    #[msg("Invalid amount: must be greater than zero")]
    InvalidAmount, // Used in: add_liquidity, remove_liquidity, execute_trade

    #[msg("Pool has already started: cannot modify initial state")]
    PoolAlreadyStarted, // Used in: initialize_pool

    #[msg("Pool is paused: trading is temporarily disabled")]
    PoolPaused, // Used in: execute_trade

    #[msg("Emergency pause active: trading is disabled due to emergency")]
    EmergencyPaused, // Used in: execute_trade

    #[msg("Invalid token account: owner or mint mismatch")]
    InvalidTokenAccount, // Used in: add_liquidity, remove_liquidity, execute_trade

    #[msg("Token account is delegated: must be owner")]
    TokenAccountDelegated, // Used in: add_liquidity, remove_liquidity, execute_trade

    #[msg("Invalid pool authority: PDA derivation failed")]
    InvalidPoolAuthority, // Used in: add_liquidity, remove_liquidity, execute_trade

    #[msg("Balance validation failed: token transfer amounts mismatch")]
    InvalidBalance, // Used in: add_liquidity, remove_liquidity, execute_trade

    #[msg("Insufficient pool balance: below minimum trade size")]
    InsufficientPoolBalance, // Used in: execute_trade

    #[msg("Insufficient liquidity: cannot withdraw more than available")]
    InsufficientLiquidity, // Used in: remove_liquidity

    #[msg("Snipe protection is active: trading not allowed in protection window")]
    SnipeProtectionActive, // Used in: execute_trade

    #[msg("Trader is blacklisted: trading not allowed")]
    TraderBlacklisted, // Used in: execute_trade

    #[msg("Rate limit exceeded: too many trades in window")]
    RateLimitExceeded, // Used in: execute_trade

    #[msg("Circuit breaker cooldown active: must wait before reset")]
    CircuitBreakerCooldown, // Used in: reset_circuit_breaker

    #[msg("Daily volume limit exceeded: above maximum threshold")]
    DailyVolumeLimitExceeded, // Used in: execute_trade

    #[msg("Price impact too high: exceeds maximum allowed")]
    PriceImpactTooHigh, // Used in: execute_trade

    #[msg("Fee too low: below minimum threshold")]
    FeeTooLow, // Used in: initialize_pool, schedule_parameter_update

    #[msg("Fee too high: above maximum threshold")]
    FeeTooHigh, // Used in: initialize_pool, schedule_parameter_update

    #[msg("Slippage exceeded: price moved unfavorably")]
    SlippageExceeded, // Used in: execute_trade

    #[msg("Arithmetic overflow: calculation exceeds u64 bounds")]
    Overflow, // Used in: execute_trade, calculate_fee

    #[msg("Invalid admin: must be current pool admin")]
    InvalidAdmin, // Used in: add_liquidity, remove_liquidity, withdraw_fees

    #[msg("Trader already blacklisted: cannot add again")]
    TraderAlreadyBlacklisted, // Used in: blacklist_trader

    #[msg("Trader not blacklisted: cannot remove")]
    TraderNotBlacklisted, // Used in: remove_from_blacklist

    #[msg("No fees available to withdraw: balance is zero")]
    NoFeesAvailable, // Used in: withdraw_fees

    #[msg("Fee tiers already locked: cannot modify")]
    FeeTiersLocked, // Used in: schedule_parameter_update

    #[msg("Fee tiers not locked: must be locked first")]
    FeeTiersNotLocked, // Used in: unlock_fee_tiers

    #[msg("Invalid fee tier configuration: check thresholds and fees")]
    InvalidFeeTier, // Used in: initialize_pool, schedule_parameter_update

    #[msg("Too many fee tiers: exceeds maximum limit")]
    TooManyFeeTiers, // Used in: initialize_pool, schedule_parameter_update

    #[msg("Duplicate fee tier threshold: must be unique")]
    DuplicateFeeTierThreshold, // Used in: initialize_pool, schedule_parameter_update

    #[msg("Invalid fee tier spacing: below minimum required")]
    InvalidFeeTierSpacing, // Used in: initialize_pool, schedule_parameter_update

    #[msg("No pending update available: must schedule first")]
    NoPendingUpdate, // Used in: apply_parameter_update

    #[msg("Timelock not yet expired: must wait for delay")]
    TimelockNotExpired, // Used in: apply_parameter_update

    #[msg("Invalid parameter relationship: check constraints")]
    InvalidParameterRelationship, // Used in: schedule_parameter_update

    #[msg("Invalid emergency admin: must be current emergency admin")]
    InvalidEmergencyAdmin, // Used in: schedule_emergency_pause, apply_emergency_pause

    #[msg("Admin update too frequent: must wait for cooldown")]
    AdminUpdateTooFrequent, // Used in: update_admin

    #[msg("Invalid new admin: cannot be current or emergency admin")]
    InvalidNewAdmin, // Used in: update_admin

    #[msg("Too many traders in batch: exceeds maximum limit")]
    TooManyTraders, // Used in: batch_blacklist_traders

    #[msg("Blacklist is full: cannot add more traders")]
    BlacklistFull, // Used in: blacklist_trader, batch_blacklist_traders

    #[msg("Invalid rate limit: check window and max values")]
    InvalidRateLimit, // Used in: initialize_pool, schedule_parameter_update

    #[msg("Token mint has freeze authority: must be revoked")]
    TokenMintHasFreezeAuthority, // Used in: initialize_pool

    #[msg("Invalid token decimals: must be zero")]
    InvalidTokenDecimals, // Used in: initialize_pool

    #[msg("Pool is already initialized: cannot initialize again")]
    PoolAlreadyInitialized, // Used in: initialize_pool

    #[msg("Circuit breaker triggered: volume exceeds threshold")]
    CircuitBreakerTriggered, // Used in: execute_trade

    #[msg("Invalid freeze authority state: must be revoked")]
    InvalidFreezeAuthorityState, // Used in: initialize_pool

    #[msg("Operation failed: check reason for details")]
    OperationFailed, // Used in: execute_trade, add_liquidity, remove_liquidity

    #[msg("Invalid operation: not supported")]
    InvalidOperation, // Used in: execute_trade

    #[msg("Invalid reason: must be non-empty")]
    InvalidReason, // Used in: execute_trade

    #[msg("Invalid pool balance: must be positive")]
    InvalidPoolBalance, // Used in: execute_trade

    #[msg("Pool is finalized: no further changes allowed")]
    PoolFinalized, // Used in: schedule_parameter_update

    #[msg("Pool is not paused: cannot resume")]
    PoolNotPaused, // Used in: apply_emergency_resume

    #[msg("Account too large: exceeds Solana's maximum size")]
    AccountTooLarge, // Used in: initialize_pool
}

// --- Event Definitions ---
#[event]
pub struct TradeExecutionFailed {
    pub pool: Pubkey,
    pub buyer: Pubkey,
    pub amount_in: u64,
    pub reason: String,
    pub ts: i64,
}

#[event]
pub struct LiquidityOperationFailed {
    pub pool: Pubkey,
    pub admin: Pubkey,
    pub operation: String,
    pub amount: u64,
    pub reason: String,
    pub ts: i64,
}

#[event]
pub struct AdminOperationFailed {
    pub pool: Pubkey,
    pub admin: Pubkey,
    pub operation: String,
    pub reason: String,
    pub ts: i64,
}

// Helper function for fee calculation
fn apply_minimum_fee(fee: u64) -> Result<u64> {
    Ok(fee.max(MINIMUM_FEE))
}

// Helper macro for common validations
#[macro_export]
macro_rules! require_positive {
    ($amount:expr) => {
        require!($amount > 0, ErrorCode::InvalidAmount)
    };
}

// Helper function for PDA derivation
fn derive_pool_authority(pool_state: &Pubkey, program_id: &Pubkey) -> Result<(Pubkey, u8)> {
    Pubkey::find_program_address(
        &[b"pool_authority", pool_state.as_ref()],
        program_id,
    ).ok_or(ErrorCode::InvalidPoolAuthority)
}

mod utils {
    use super::*;

    // Helper macro for admin validation
    #[macro_export]
    macro_rules! require_admin {
        ($ctx:expr, $pool_state:expr) => {
            require!(
                $ctx.accounts.admin.key() == $pool_state.admin,
                ErrorCode::InvalidAdmin
            )
        };
    }

    // Helper macro for emergency admin validation
    #[macro_export]
    macro_rules! require_emergency_admin {
        ($ctx:expr, $pool_state:expr) => {
            require!(
                $ctx.accounts.emergency_admin.key() == $pool_state.emergency_admin,
                ErrorCode::InvalidEmergencyAdmin
            )
        };
    }

    // Helper macro for pool state validation
    #[macro_export]
    macro_rules! require_pool_active {
        ($pool_state:expr) => {
            require!(!$pool_state.is_paused, ErrorCode::PoolPaused);
            require!(!$pool_state.is_emergency_paused, ErrorCode::EmergencyPaused);
            require!(!$pool_state.is_finalized, ErrorCode::PoolFinalized);
        };
    }

    pub fn calculate_fee(pool_state: &PoolState, amount_in: u64, current_time: i64) -> Result<(u64, u8)> {
        // Early trade fee if within protection window
        if current_time - pool_state.pool_start_time as i64 <= pool_state.trade_settings.early_trade_window_seconds as i64 {
            let fee = amount_in
                .checked_mul(pool_state.trade_settings.early_trade_fee_bps)
                .ok_or(ErrorCode::Overflow)?
                .checked_div(10000)
                .ok_or(ErrorCode::Overflow)?;
            
            // Use default fee if configured, otherwise minimum fee
            let effective_fee = if fee == 0 {
                pool_state.default_fee_bps
                    .map(|bps| amount_in.checked_mul(bps).ok_or(ErrorCode::Overflow)?.checked_div(10000).ok_or(ErrorCode::Overflow)?)
                    .unwrap_or(MINIMUM_FEE)
            } else {
                fee.max(MINIMUM_FEE)
            };
            
            return Ok((effective_fee, FEE_MODE_EARLY_TRADE));
        }

        // Find applicable fee tier based on volume
        for tier in &pool_state.fee_tiers {
            if pool_state.volume.volume_24h <= tier.volume_threshold {
                let fee = amount_in
                    .checked_mul(tier.fee_bps)
                    .ok_or(ErrorCode::Overflow)?
                    .checked_div(10000)
                    .ok_or(ErrorCode::Overflow)?;
                
                // Use default fee if configured, otherwise minimum fee
                let effective_fee = if fee == 0 {
                    pool_state.default_fee_bps
                        .map(|bps| amount_in.checked_mul(bps).ok_or(ErrorCode::Overflow)?.checked_div(10000).ok_or(ErrorCode::Overflow)?)
                        .unwrap_or(MINIMUM_FEE)
                } else {
                    fee.max(MINIMUM_FEE)
                };
                
                return Ok((effective_fee, FEE_MODE_TIER_BASED));
            }
        }

        // Use default fee if configured, otherwise minimum fee
        let fallback_fee = pool_state.default_fee_bps
            .map(|bps| amount_in.checked_mul(bps).ok_or(ErrorCode::Overflow)?.checked_div(10000).ok_or(ErrorCode::Overflow)?)
            .unwrap_or(MINIMUM_FEE);

        Ok((fallback_fee, FEE_MODE_NONE))
    }

    pub fn derive_pool_authority(pool_state: &Pubkey, program_id: &Pubkey) -> Result<(Pubkey, u8)> {
        Pubkey::find_program_address(
            &[b"pool_authority", pool_state.as_ref()],
            program_id,
        ).ok_or(ErrorCode::InvalidPoolAuthority)
    }

    pub fn validate_trader(trader: &Pubkey, pool_state: &PoolState) -> Result<()> {
        require!(*trader != Pubkey::default(), ErrorCode::InvalidTrader);
        require!(*trader != pool_state.admin, ErrorCode::InvalidTrader);
        require!(*trader != pool_state.emergency_admin, ErrorCode::InvalidTrader);
        Ok(())
    }

    pub fn simulate_trade(
        pool_state: &PoolState,
        amount_in: u64,
        current_time: i64,
    ) -> Result<TradeSimulation> {
        let (fee_amount, fee_mode) = calculate_fee(pool_state, amount_in, current_time)?;
        let amount_out = amount_in.checked_sub(fee_amount).ok_or(ErrorCode::Overflow)?;
        let price_impact = calculate_price_impact(amount_in, pool_state.total_liquidity)?;

        Ok(TradeSimulation {
            amount_in,
            amount_out,
            fee_amount,
            fee_mode,
            price_impact,
        })
    }

    pub fn estimate_slippage(
        pool_state: &PoolState,
        amount_in: u64,
        slippage_bps: u64,
    ) -> Result<SlippageEstimate> {
        let current_time = Clock::get()?.unix_timestamp as i64;
        let simulation = simulate_trade(pool_state, amount_in, current_time)?;
        
        let min_amount_out = simulation.amount_out
            .checked_mul(10000 - slippage_bps)
            .ok_or(ErrorCode::Overflow)?
            .checked_div(10000)
            .ok_or(ErrorCode::Overflow)?;

        Ok(SlippageEstimate {
            expected_amount_out: simulation.amount_out,
            min_amount_out,
            price_impact: simulation.price_impact,
            fee_amount: simulation.fee_amount,
        })
    }

    pub fn process_blacklist_operations(
        pool_state: &mut PoolState,
        traders: Vec<Pubkey>,
        operation: BlacklistOperation,
        current_time: u64,
    ) -> Result<()> {
        // Validate input size
        if traders.is_empty() {
            return Err(ErrorCode::InvalidOperation.into());
        }
        if traders.len() > 100 {
            return Err(ErrorCode::TooManyTraders.into());
        }

        // Convert to HashSet for O(1) lookups
        let mut blacklist_set: std::collections::HashSet<Pubkey> = 
            pool_state.trader_blacklist.iter().cloned().collect();

        match operation {
            BlacklistOperation::Add => {
                // Deduplicate traders
                let unique_traders: Vec<Pubkey> = traders.into_iter()
                    .filter(|trader| !blacklist_set.contains(trader))
                    .collect();

                // Check if adding would exceed blacklist size
                if blacklist_set.len() + unique_traders.len() > 1000 {
                    return Err(ErrorCode::BlacklistFull.into());
                }

                // Add traders and emit events
                for trader in &unique_traders {
                    blacklist_set.insert(*trader);
                    emit!(TraderBlacklisted {
                        pool: pool_state.key(),
                        trader_pubkey: *trader,
                        ts: current_time as i64,
                    });
                }

                // Update pool state
                pool_state.trader_blacklist = blacklist_set.into_iter().collect();
                pool_state.trader_blacklist.sort(); // Keep sorted for consistency

                emit!(BatchBlacklistCompleted {
                    pool: pool_state.key(),
                    admin_pubkey: pool_state.admin,
                    count: unique_traders.len() as u64,
                    ts: current_time as i64,
                });
            }
            BlacklistOperation::Remove => {
                let mut removed_count = 0;
                for trader in &traders {
                    if blacklist_set.remove(trader) {
                        removed_count += 1;
                        emit!(TraderRemovedFromBlacklist {
                            pool: pool_state.key(),
                            trader_pubkey: *trader,
                            ts: current_time as i64,
                        });
                    }
                }

                // Update pool state
                pool_state.trader_blacklist = blacklist_set.into_iter().collect();
                pool_state.trader_blacklist.sort(); // Keep sorted for consistency

                emit!(BatchBlacklistCompleted {
                    pool: pool_state.key(),
                    admin_pubkey: pool_state.admin,
                    count: removed_count,
                    ts: current_time as i64,
                });
            }
        }

        Ok(())
    }
}

// Add new struct for trade simulation
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct TradeSimulation {
    pub amount_in: u64,
    pub amount_out: u64,
    pub fee_amount: u64,
    pub fee_mode: u8,
    pub price_impact: u64,
}

// Add new event for rate limit resets
#[event]
pub struct RateLimitReset {
    pub pool: Pubkey,
    pub old_count: u32,
    pub new_count: u32,
    pub ts: i64,
}

// Add new event for price impact rejections
#[event]
pub struct PriceImpactRejected {
    pub pool: Pubkey,
    pub amount_in: u64,
    pub price_impact: u64,
    pub max_allowed: u64,
    pub ts: i64,
}

// Add new instruction for trade simulation
pub fn simulate_trade_execution(
    ctx: Context<contexts::SimulateTrade>,
    amount_in: u64,
) -> Result<TradeSimulation> {
    let pool_state = &ctx.accounts.pool_state;
    let current_time = Clock::get()?.unix_timestamp as i64;
    
    utils::simulate_trade(pool_state, amount_in, current_time)
}

// Add new account struct for simulation
#[derive(Accounts)]
pub struct SimulateTrade<'info> {
    pub pool_state: Account<'info, PoolState>,
}

// Add enum for blacklist operations
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum BlacklistOperation {
    Add,
    Remove,
}

// Add new structs for view functions
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct SlippageEstimate {
    pub expected_amount_out: u64,
    pub min_amount_out: u64,
    pub price_impact: u64,
    pub fee_amount: u64,
}

// Add new view functions
pub fn estimate_trade_slippage(
    ctx: Context<contexts::SimulateTrade>,
    amount_in: u64,
    slippage_bps: u64,
) -> Result<SlippageEstimate> {
    let pool_state = &ctx.accounts.pool_state;
    utils::estimate_slippage(pool_state, amount_in, slippage_bps)
}

#[macro_export]
macro_rules! validate_condition {
    ($condition:expr, $error:expr) => {
        if !$condition {
            return Err($error.into());
        }
    };
}

#[macro_export]
macro_rules! validate_parameter {
    ($value:expr, $min:expr, $max:expr, $error:expr) => {
        validate_condition!($value >= $min && $value <= $max, $error);
    };
}

mod validation {
    use super::*;

    pub fn validate_trade_parameters(
        pool_state: &PoolState,
        amount_in: u64,
        current_time: u64,
    ) -> Result<()> {
        // Check if pool is paused
        validate_condition!(!pool_state.is_paused, ErrorCode::PoolPaused);
        validate_condition!(!pool_state.is_emergency_paused, ErrorCode::EmergencyPaused);

        // Validate trade size
        let max_trade_size = (pool_state.total_liquidity * pool_state.trade_settings.max_size_bps) / 10000;
        validate_condition!(
            amount_in >= pool_state.trade_settings.min_size && amount_in <= max_trade_size,
            ErrorCode::TradeTooSmall
        );

        // Check cooldown
        validate_condition!(
            current_time >= pool_state.trade_settings.last_trade_time + pool_state.trade_settings.cooldown_seconds,
            ErrorCode::RateLimitExceeded
        );

        // Check rate limit
        if current_time >= pool_state.rate_limit.last_reset + pool_state.rate_limit.window {
            pool_state.reset_rate_limit(current_time)?;
        }
        validate_condition!(
            pool_state.rate_limit.count < pool_state.rate_limit.max,
            ErrorCode::RateLimitExceeded
        );

        // Check circuit breaker
        validate_condition!(
            pool_state.volume.volume_24h <= pool_state.circuit_breaker.threshold,
            ErrorCode::CircuitBreakerTriggered
        );

        // Check daily volume
        validate_condition!(
            pool_state.volume.volume_24h + amount_in <= pool_state.volume.max_daily,
            ErrorCode::DailyVolumeLimitExceeded
        );

        // Check price impact
        let price_impact = utils::calculate_price_impact(amount_in, pool_state.total_liquidity)?;
        validate_condition!(
            price_impact <= pool_state.protection.max_price_impact_bps,
            ErrorCode::PriceImpactTooHigh
        );

        Ok(())
    }

    pub fn validate_fee_parameters(
        pool_state: &PoolState,
        fee_tiers: &[FeeTier],
    ) -> Result<()> {
        // Check if fee tiers are locked
        validate_condition!(!pool_state.fee_tiers_locked, ErrorCode::FeeTiersLocked);

        // Validate fee tiers
        validate_condition!(!fee_tiers.is_empty(), ErrorCode::InvalidFeeTier);
        validate_condition!(fee_tiers.len() <= 100, ErrorCode::TooManyFeeTiers);

        // Check for duplicates and validate thresholds
        let mut prev_threshold = 0;
        for tier in fee_tiers {
            validate_parameter!(tier.threshold, prev_threshold + 1, u64::MAX, ErrorCode::InvalidFeeTierSpacing);
            validate_parameter!(tier.fee_bps, 0, 10000, ErrorCode::FeeTooHigh);
            prev_threshold = tier.threshold;
        }

        Ok(())
    }

    pub fn validate_admin_action(
        pool_state: &PoolState,
        admin: &Pubkey,
        current_time: u64,
    ) -> Result<()> {
        validate_condition!(admin == &pool_state.admin, ErrorCode::Unauthorized);
        validate_condition!(!pool_state.is_finalized, ErrorCode::PoolFinalized);
        validate_condition!(
            current_time >= pool_state.last_admin_update + 86400,
            ErrorCode::AdminUpdateTooFrequent
        );
        Ok(())
    }
}

// Update execute_trade to use the new validation
pub fn execute_trade(
    ctx: Context<contexts::ExecuteTrade>,
    amount_in: u64,
    minimum_amount_out: u64,
) -> Result<TradeOutcome> {
    validate_token_program!(ctx.accounts.token_program);
    
    let state = &mut ctx.accounts.pool_state;
    let current_time = current_unix_ts()?;

    // Validate trade parameters
    validation::validate_trade_parameters(state, amount_in, current_time)?;

    // Validate token accounts
    state.check_token_mint(&ctx.accounts.token_mint)?;
    state.check_token_account(&ctx.accounts.buyer_token_account, &state.token_mint)?;
    state.check_token_account(&ctx.accounts.pool_token_account, &state.token_mint)?;

    // Calculate fee and amount out
    let (fee_amount, fee_mode) = state.calculate_fee(amount_in, current_time as i64)?;
    let amount_out = amount_in
        .checked_sub(fee_amount)
        .ok_or(ErrorCode::Overflow)?;

    let price_impact = state.calculate_price_impact(amount_in, ctx.accounts.pool_token_account.amount)?;

    // Validate against minimum amount out
    require!(
        amount_out >= minimum_amount_out,
        ErrorCode::SlippageExceeded,
        "Amount out {} is less than minimum {}",
        amount_out,
        minimum_amount_out
    );

    // Validate against pool liquidity
    require!(
        amount_out <= ctx.accounts.pool_token_account.amount,
        ErrorCode::InsufficientPoolBalance,
        "Amount out {} exceeds pool balance {}",
        amount_out,
        ctx.accounts.pool_token_account.amount
    );

    // Transfer tokens from buyer to pool
    let cpi_context = with_pool_signer(
        &ctx.program_id,
        state,
        &[ctx.accounts.pool_authority.to_account_info()],
    )?;

    token::transfer(
        cpi_context,
        amount_in,
    )?;

    // Update pool state
    state.total_fees_collected = state.total_fees_collected.saturating_add(fee_amount);
    state.trade_settings.last_trade_time = current_time;
    state.rate_limit.count = state.rate_limit.count.saturating_add(1);
    state.volume.volume_24h = state.volume.volume_24h.saturating_add(amount_in);

    // Emit trade event
    state.emit_trade_executed(
        &ctx.accounts.buyer.key(),
        amount_in,
        amount_out,
        fee_amount,
        fee_mode,
        current_time as i64,
    );

    Ok(TradeOutcome {
        amount_out,
        fee_amount,
        fee_mode,
        price_impact,
        timestamp: current_time as i64,
    })
}

pub fn apply_parameter_update(ctx: Context<contexts::AdminAction>) -> Result<()> {
    let state = &mut ctx.accounts.pool_state;
    let current_time = current_unix_ts()?;

    // Validate admin and timelock
    validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;
    validate_condition!(
        state.pending_update.is_some(),
        ErrorCode::NoPendingUpdate,
        "No pending update available"
    );

    let pending_update = state.pending_update.as_ref().unwrap();
    validate_condition!(
        current_time >= pending_update.scheduled_time,
        ErrorCode::TimelockNotExpired,
        "Timelock not yet expired"
    );

    // Apply updates and emit events
    if let Some(trade_settings) = &pending_update.trade_settings {
        state.trade_settings.early_trade_fee_bps = trade_settings.early_trade_fee_bps;
        state.trade_settings.early_trade_window_seconds = trade_settings.early_trade_window_seconds;
        state.trade_settings.max_size_bps = trade_settings.max_trade_size_bps;
        state.trade_settings.min_size = trade_settings.min_trade_size;
        state.trade_settings.cooldown_seconds = trade_settings.cooldown_seconds;

        emit!(TradeSettingsUpdated {
            pool: state.key(),
            admin_pubkey: ctx.accounts.admin.key(),
            early_trade_fee_bps: trade_settings.early_trade_fee_bps,
            early_trade_window_seconds: trade_settings.early_trade_window_seconds,
            max_trade_size_bps: trade_settings.max_trade_size_bps,
            min_trade_size: trade_settings.min_trade_size,
            cooldown_seconds: trade_settings.cooldown_seconds,
            ts: current_time as i64,
        });
    }

    if let Some(protection_settings) = &pending_update.protection_settings {
        state.volume.max_daily = protection_settings.max_daily_volume;
        state.protection.max_price_impact_bps = protection_settings.max_price_impact_bps;
        state.circuit_breaker.threshold = protection_settings.circuit_breaker_threshold;
        state.circuit_breaker.window = protection_settings.circuit_breaker_window;
        state.circuit_breaker.cooldown = protection_settings.circuit_breaker_cooldown;
        state.rate_limit.window = protection_settings.rate_limit_window;
        state.rate_limit.max = protection_settings.rate_limit_max;

        emit!(ProtectionSettingsUpdated {
            pool: state.key(),
            admin_pubkey: ctx.accounts.admin.key(),
            max_daily_volume: protection_settings.max_daily_volume,
            max_price_impact_bps: protection_settings.max_price_impact_bps,
            circuit_breaker_threshold: protection_settings.circuit_breaker_threshold,
            circuit_breaker_window: protection_settings.circuit_breaker_window,
            circuit_breaker_cooldown: protection_settings.circuit_breaker_cooldown,
            rate_limit_window: protection_settings.rate_limit_window,
            rate_limit_max: protection_settings.rate_limit_max,
            ts: current_time as i64,
        });
    }

    if let Some(fee_settings) = &pending_update.fee_settings {
        if !fee_settings.fee_tiers.is_empty() {
            state.fee_tiers = fee_settings.fee_tiers.clone();
        }
        state.fee_tiers_locked = fee_settings.fee_tiers_locked;

        emit!(FeeSettingsUpdated {
            pool: state.key(),
            admin_pubkey: ctx.accounts.admin.key(),
            fee_tiers_count: state.fee_tiers.len(),
            fee_tiers_locked: state.fee_tiers_locked,
            ts: current_time as i64,
        });
    }

    if let Some(state_settings) = &pending_update.state_settings {
        state.is_paused = state_settings.is_paused;
        state.is_emergency_paused = state_settings.is_emergency_paused;

        emit!(StateSettingsUpdated {
            pool: state.key(),
            admin_pubkey: ctx.accounts.admin.key(),
            is_paused: state_settings.is_paused,
            is_emergency_paused: state_settings.is_emergency_paused,
            ts: current_time as i64,
        });
    }

    // Clear pending update
    state.pending_update = None;
    state.last_update = current_time;

    emit!(ParametersUpdated {
        pool: state.key(),
        admin_pubkey: ctx.accounts.admin.key(),
        ts: current_time as i64,
    });

    Ok(())
}

pub trait ValidationHelpers {
    fn check_token_account_ownership(&self, owner: &Pubkey) -> Result<()>;
    fn check_pool_authority(&self, authority: &Pubkey, program_id: &Pubkey) -> Result<()>;
    fn check_token_mint(&self, mint: &Account<Mint>) -> Result<()>;
    fn check_token_account(&self, account: &Account<TokenAccount>, mint: &Pubkey) -> Result<()>;
    fn check_circuit_breaker(&self, current_time: u64) -> Result<()>;
    fn check_rate_limit(&self, current_time: u64) -> Result<()>;
    fn check_volume_limit(&self, amount: u64) -> Result<()>;
}

impl ValidationHelpers for PoolState {
    fn check_token_account_ownership(&self, owner: &Pubkey) -> Result<()> {
        validate_condition!(owner == &self.admin, ErrorCode::Unauthorized);
        Ok(())
    }

    fn check_pool_authority(&self, authority: &Pubkey, program_id: &Pubkey) -> Result<()> {
        let (expected_authority, _) = derive_pool_authority(&self.key(), program_id)?;
        validate_condition!(authority == &expected_authority, ErrorCode::InvalidPoolAuthority);
        Ok(())
    }

    fn check_token_mint(&self, mint: &Account<Mint>) -> Result<()> {
        validate_condition!(mint.key() == self.token_mint, ErrorCode::InvalidTokenMint);
        validate_condition!(mint.decimals == self.token_decimals, ErrorCode::InvalidTokenDecimals);
        validate_condition!(mint.freeze_authority.is_none(), ErrorCode::TokenMintHasFreezeAuthority);
        Ok(())
    }

    fn check_token_account(&self, account: &Account<TokenAccount>, mint: &Pubkey) -> Result<()> {
        validate_condition!(account.mint == *mint, ErrorCode::InvalidTokenAccount);
        validate_condition!(!account.is_delegated(), ErrorCode::TokenAccountDelegated);
        Ok(())
    }

    fn check_circuit_breaker(&self, current_time: u64) -> Result<()> {
        validate_condition!(current_time >= self.circuit_breaker.last_trigger + self.circuit_breaker.cooldown, ErrorCode::CircuitBreakerCooldown);
        Ok(())
    }

    fn check_rate_limit(&self, current_time: u64) -> Result<()> {
        validate_condition!(current_time < self.rate_limit.last_reset + self.rate_limit.window, ErrorCode::RateLimitExceeded);
        validate_condition!(self.rate_limit.count < self.rate_limit.max, ErrorCode::RateLimitExceeded);
        Ok(())
    }

    fn check_volume_limit(&self, amount: u64) -> Result<()> {
        validate_condition!(self.volume.volume_24h + amount <= self.volume.max_daily, ErrorCode::DailyVolumeLimitExceeded);
        Ok(())
    }
}

// Constants for space calculation
pub const MAX_PENDING_UPDATE_SIZE: usize = std::mem::size_of::<PendingUpdate>();
pub const MAX_FEE_TIERS: usize = 100;
pub const MAX_BLACKLIST_SIZE: usize = 1000;

// Operation enum for better error reporting
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug)]
pub enum Operation {
    ExecuteTrade,
    AddLiquidity,
    RemoveLiquidity,
    BlacklistTrader,
    RemoveFromBlacklist,
    WithdrawFees,
    UpdateParameters,
    EmergencyPause,
    EmergencyResume,
}

impl Operation {
    pub fn as_str(&self) -> &'static str {
        match self {
            Operation::ExecuteTrade => "ExecuteTrade",
            Operation::AddLiquidity => "AddLiquidity",
            Operation::RemoveLiquidity => "RemoveLiquidity",
            Operation::BlacklistTrader => "BlacklistTrader",
            Operation::RemoveFromBlacklist => "RemoveFromBlacklist",
            Operation::WithdrawFees => "WithdrawFees",
            Operation::UpdateParameters => "UpdateParameters",
            Operation::EmergencyPause => "EmergencyPause",
            Operation::EmergencyResume => "EmergencyResume",
        }
    }
}

// Helper function for fee calculation
pub fn calculate_fee_from_bps(amount: u64, bps: u64) -> Result<u64> {
    amount
        .checked_mul(bps)
        .ok_or(ErrorCode::Overflow)?
        .checked_div(10000)
        .ok_or(ErrorCode::Overflow)
}

// Event emission helpers
pub trait EventHelpers {
    fn emit_pool_initialized(&self, admin: &Pubkey, ts: i64);
    fn emit_liquidity_added(&self, admin: &Pubkey, amount: u64, ts: i64);
    fn emit_liquidity_removed(&self, admin: &Pubkey, amount: u64, ts: i64);
    fn emit_trade_executed(&self, buyer: &Pubkey, amount_in: u64, amount_out: u64, fee_amount: u64, fee_mode: u8, ts: i64);
    fn emit_operation_failed(&self, operation: Operation, reason: &str, ts: i64);
}

impl EventHelpers for PoolState {
    fn emit_pool_initialized(&self, admin: &Pubkey, ts: i64) {
        emit!(PoolInitialized {
            pool: self.key(),
            admin_pubkey: *admin,
            ts,
        });
    }

    fn emit_liquidity_added(&self, admin: &Pubkey, amount: u64, ts: i64) {
        emit!(LiquidityAdded {
            pool: self.key(),
            admin_pubkey: *admin,
            amount,
            ts,
        });
    }

    fn emit_liquidity_removed(&self, admin: &Pubkey, amount: u64, ts: i64) {
        emit!(LiquidityRemoved {
            pool: self.key(),
            admin_pubkey: *admin,
            amount,
            ts,
        });
    }

    fn emit_trade_executed(&self, buyer: &Pubkey, amount_in: u64, amount_out: u64, fee_amount: u64, fee_mode: u8, ts: i64) {
        emit!(TradeExecuted {
            pool: self.key(),
            buyer_pubkey: *buyer,
            amount_in,
            amount_out,
            fee_amount,
            fee_mode,
            ts,
            token_mint: self.token_mint,
        });
    }

    fn emit_operation_failed(&self, operation: Operation, reason: &str, ts: i64) {
        emit!(OperationFailed {
            pool: self.key(),
            operation: operation.as_str().to_string(),
            reason: reason.to_string(),
            ts,
        });
    }
}

// Update calculate_space to use constants
impl PoolState {
    pub fn calculate_space() -> usize {
        let size = 8 + // discriminator
            1 + // version
            1 + // migration_flag
            1 + // is_initialized
            32 + // admin
            32 + // emergency_admin
            32 + // token_mint
            1 + // token_decimals
            8 + // total_fees_collected
            8 + // total_liquidity
            1 + // is_paused
            1 + // is_emergency_paused
            1 + // is_finalized
            8 + // pool_start_time
            8 + // last_update
            8 + // last_admin_update
            8 + // emergency_action_scheduled_time
            1 + // pending_update Option discriminator
            MAX_PENDING_UPDATE_SIZE + // pending_update
            8 + // trade_settings max_size_bps
            8 + // trade_settings min_size
            8 + // trade_settings cooldown_seconds
            8 + // trade_settings last_trade_time
            8 + // trade_settings early_trade_fee_bps
            8 + // trade_settings early_trade_window_seconds
            8 + // rate_limit window
            4 + // rate_limit count
            4 + // rate_limit max
            8 + // rate_limit last_reset
            8 + // circuit_breaker threshold
            8 + // circuit_breaker window
            8 + // circuit_breaker cooldown
            8 + // circuit_breaker last_trigger
            8 + // volume volume_24h
            8 + // volume last_update
            8 + // volume last_decay
            8 + // volume max_daily
            8 + // protection snipe_protection_seconds
            8 + // protection max_price_impact_bps
            4 + // fee_tiers Vec length
            (32 * MAX_FEE_TIERS) + // fee_tiers Vec capacity
            1 + // fee_tiers_locked
            1 + // default_fee_bps Option discriminator
            8 + // default_fee_bps
            4 + // trader_blacklist Vec length
            (32 * MAX_BLACKLIST_SIZE); // trader_blacklist Vec capacity

        if size > 10240 {
            panic!("Account size {} exceeds Solana's maximum size of 10240 bytes", size);
        }

        size
    }
}

impl<'info> Drop for ReentrancyGuard<'info> {
    fn drop(&mut self) {
        // Reset the reentrancy guard when the scope ends
        if let Some(guard) = self.guard.as_ref() {
            guard.try_borrow_mut().map(|mut guard| {
                *guard = false;
            }).ok();
        }
    }
}

pub fn withdraw_collected_fees(ctx: Context<contexts::WithdrawCollectedFees>) -> Result<()> {
    let state = &mut ctx.accounts.pool_state;
    let current_time = Clock::get()?.unix_timestamp as u64;

    // Validate admin and check cooldown
    validation::validate_admin_action(state, &ctx.accounts.admin.key(), current_time)?;

    // Validate token accounts
    state.check_token_mint(&ctx.accounts.token_mint)?;
    state.check_token_account(&ctx.accounts.pool_token_account, &state.token_mint)?;
    state.check_token_account(&ctx.accounts.admin_token_account, &state.token_mint)?;

    // Validate admin token account ownership
    require!(
        ctx.accounts.admin_token_account.owner == ctx.accounts.admin.key(),
        ErrorCode::InvalidTokenAccount,
        "Admin token account owner {} does not match admin {}",
        ctx.accounts.admin_token_account.owner,
        ctx.accounts.admin.key()
    );

    // Check if fees are available
    require!(
        state.total_fees_collected > 0,
        ErrorCode::NoFeesAvailable,
        "No fees available to withdraw"
    );

    // Transfer fees from pool to admin
    let cpi_context = with_pool_signer(
        &ctx.program_id,
        state,
        &[ctx.accounts.pool_authority.to_account_info()],
    )?;

    token::transfer(
        cpi_context,
        state.total_fees_collected,
    )?;

    // Update pool state
    state.total_fees_collected = 0;
    state.last_update = current_time;

    // Emit event
    emit!(FeesWithdrawn {
        pool: state.key(),
        admin_pubkey: state.admin,
        amount: state.total_fees_collected,
        ts: current_time as i64,
    });

    Ok(())
}

#[event]
pub struct TradeSettingsUpdated {
    pub pool: Pubkey,
    pub admin_pubkey: Pubkey,
    pub early_trade_fee_bps: u64,
    pub early_trade_window_seconds: u64,
    pub max_trade_size_bps: u64,
    pub min_trade_size: u64,
    pub cooldown_seconds: u64,
    pub ts: i64,
}

#[event]
pub struct ProtectionSettingsUpdated {
    pub pool: Pubkey,
    pub admin_pubkey: Pubkey,
    pub max_daily_volume: u64,
    pub max_price_impact_bps: u64,
    pub circuit_breaker_threshold: u64,
    pub circuit_breaker_window: u64,
    pub circuit_breaker_cooldown: u64,
    pub rate_limit_window: u64,
    pub rate_limit_max: u32,
    pub ts: i64,
}

#[event]
pub struct FeeSettingsUpdated {
    pub pool: Pubkey,
    pub admin_pubkey: Pubkey,
    pub fee_tiers_count: usize,
    pub fee_tiers_locked: bool,
    pub ts: i64,
}

#[event]
pub struct StateSettingsUpdated {
    pub pool: Pubkey,
    pub admin_pubkey: Pubkey,
    pub is_paused: bool,
    pub is_emergency_paused: bool,
    pub ts: i64,
}

// --- Cooldowns ---
pub const EMERGENCY_TIMELOCK_SECONDS: u64 = 3600; // 1 hour
pub const PARAMETER_UPDATE_TIMELOCK: u64 = 86400; // 24 hours
pub const ADMIN_UPDATE_COOLDOWN: u64 = 86400; // 24 hours

// --- Limits ---
pub const MAX_FEE_TIERS: usize = 100;
pub const MAX_BLACKLIST_SIZE: usize = 1000;
pub const MAX_PENDING_UPDATE_SIZE: usize = std::mem::size_of::<PendingUpdate>();

// --- Fee Mode Enum ---
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FeeMode {
    None = 0,
    EarlyTrade = 1,
    TierBased = 2,
}

impl FeeMode {
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }

    pub fn from_u8(mode: u8) -> Option<Self> {
        match mode {
            0 => Some(FeeMode::None),
            1 => Some(FeeMode::EarlyTrade),
            2 => Some(FeeMode::TierBased),
            _ => None,
        }
    }
}

// --- Operation Enum ---
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Operation {
    ExecuteTrade,
    AddLiquidity,
    RemoveLiquidity,
    BlacklistTrader,
    RemoveFromBlacklist,
    WithdrawFees,
    UpdateParameters,
    EmergencyPause,
    EmergencyResume,
}

impl Operation {
    pub fn as_str(&self) -> &'static str {
        match self {
            Operation::ExecuteTrade => "ExecuteTrade",
            Operation::AddLiquidity => "AddLiquidity",
            Operation::RemoveLiquidity => "RemoveLiquidity",
            Operation::BlacklistTrader => "BlacklistTrader",
            Operation::RemoveFromBlacklist => "RemoveFromBlacklist",
            Operation::WithdrawFees => "WithdrawFees",
            Operation::UpdateParameters => "UpdateParameters",
            Operation::EmergencyPause => "EmergencyPause",
            Operation::EmergencyResume => "EmergencyResume",
        }
    }
}

// --- Blacklist Operation Enum ---
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BlacklistOperation {
    Add,
    Remove,
}

// --- Helper Functions ---
pub fn current_unix_ts() -> Result<u64> {
    Ok(Clock::get()?.unix_timestamp as u64)
}

// --- Trade Outcome Struct ---
#[derive(Debug)]
pub struct TradeOutcome {
    pub amount_out: u64,
    pub fee_amount: u64,
    pub fee_mode: FeeMode,
    pub price_impact: u64,
    pub timestamp: i64,
}

/// Validates that the token program is the correct one
#[macro_export]
macro_rules! validate_token_program {
    ($token_program:expr) => {
        require!(
            $token_program.key() == token::ID,
            ErrorCode::InvalidTokenProgram,
            "Invalid token program: expected Token program"
        );
    };
}